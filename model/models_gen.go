// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"fmt"
	"io"
	"strconv"
)

// expression to compare columns of type Boolean. All fields are combined with logical 'AND'.
type BooleanComparisonExp struct {
	Eq     *bool  `json:"_eq"`
	Gt     *bool  `json:"_gt"`
	Gte    *bool  `json:"_gte"`
	In     []bool `json:"_in"`
	IsNull *bool  `json:"_is_null"`
	Lt     *bool  `json:"_lt"`
	Lte    *bool  `json:"_lte"`
	Neq    *bool  `json:"_neq"`
	Nin    []bool `json:"_nin"`
}

// expression to compare columns of type Int. All fields are combined with logical 'AND'.
type IntComparisonExp struct {
	Eq     *int64  `json:"_eq"`
	Gt     *int64  `json:"_gt"`
	Gte    *int64  `json:"_gte"`
	In     []int64 `json:"_in"`
	IsNull *bool   `json:"_is_null"`
	Lt     *int64  `json:"_lt"`
	Lte    *int64  `json:"_lte"`
	Neq    *int64  `json:"_neq"`
	Nin    []int64 `json:"_nin"`
}

// expression to compare columns of type String. All fields are combined with logical 'AND'.
type StringComparisonExp struct {
	Eq       *string  `json:"_eq"`
	Gt       *string  `json:"_gt"`
	Gte      *string  `json:"_gte"`
	Ilike    *string  `json:"_ilike"`
	In       []string `json:"_in"`
	IsNull   *bool    `json:"_is_null"`
	Like     *string  `json:"_like"`
	Lt       *string  `json:"_lt"`
	Lte      *string  `json:"_lte"`
	Neq      *string  `json:"_neq"`
	Nilike   *string  `json:"_nilike"`
	Nin      []string `json:"_nin"`
	Nlike    *string  `json:"_nlike"`
	Nsimilar *string  `json:"_nsimilar"`
	Similar  *string  `json:"_similar"`
}

// columns and relationships of "accounts"
type Accounts struct {
	Email     string  `json:"email"`
	LastLogin *string `json:"last_login"`
	Role      string  `json:"role"`
	// An object relationship
	User   *Users `json:"user"`
	UserID string `json:"user_id"`
}

// aggregated selection of "accounts"
type AccountsAggregate struct {
	Aggregate *AccountsAggregateFields `json:"aggregate"`
	Nodes     []*Accounts              `json:"nodes"`
}

// aggregate fields of "accounts"
type AccountsAggregateFields struct {
	Count *int64             `json:"count"`
	Max   *AccountsMaxFields `json:"max"`
	Min   *AccountsMinFields `json:"min"`
}

// order by aggregate values of table "accounts"
type AccountsAggregateOrderBy struct {
	Count *OrderBy            `json:"count"`
	Max   *AccountsMaxOrderBy `json:"max"`
	Min   *AccountsMinOrderBy `json:"min"`
}

// input type for inserting array relation for remote table "accounts"
type AccountsArrRelInsertInput struct {
	Data       []*AccountsInsertInput `json:"data"`
	OnConflict *AccountsOnConflict    `json:"on_conflict"`
}

// Boolean expression to filter rows from the table "accounts". All fields are combined with a logical 'AND'.
type AccountsBoolExp struct {
	And       []*AccountsBoolExp        `json:"_and"`
	Not       *AccountsBoolExp          `json:"_not"`
	Or        []*AccountsBoolExp        `json:"_or"`
	Email     *StringComparisonExp      `json:"email"`
	LastLogin *TimestamptzComparisonExp `json:"last_login"`
	Role      *StringComparisonExp      `json:"role"`
	User      *UsersBoolExp             `json:"user"`
	UserID    *UUIDComparisonExp        `json:"user_id"`
}

// input type for inserting data into table "accounts"
type AccountsInsertInput struct {
	Email     *string                 `json:"email" fake:"{mailgen}"`
	LastLogin *string                 `json:"last_login" fake:"skip"`
	Role      *string                 `json:"role" fake:"{rolegen}"`
	User      *UsersObjRelInsertInput `json:"user" fake:"skip"`
	UserID    *string                 `json:"user_id" fake:"{uuid}"`
}

// aggregate max on columns
type AccountsMaxFields struct {
	Email     *string `json:"email"`
	LastLogin *string `json:"last_login"`
	Role      *string `json:"role"`
	UserID    *string `json:"user_id"`
}

// order by max() on columns of table "accounts"
type AccountsMaxOrderBy struct {
	Email     *OrderBy `json:"email"`
	LastLogin *OrderBy `json:"last_login"`
	Role      *OrderBy `json:"role"`
	UserID    *OrderBy `json:"user_id"`
}

// aggregate min on columns
type AccountsMinFields struct {
	Email     *string `json:"email"`
	LastLogin *string `json:"last_login"`
	Role      *string `json:"role"`
	UserID    *string `json:"user_id"`
}

// order by min() on columns of table "accounts"
type AccountsMinOrderBy struct {
	Email     *OrderBy `json:"email"`
	LastLogin *OrderBy `json:"last_login"`
	Role      *OrderBy `json:"role"`
	UserID    *OrderBy `json:"user_id"`
}

// response of any mutation on the table "accounts"
type AccountsMutationResponse struct {
	// number of affected rows by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data of the affected rows by the mutation
	Returning []*Accounts `json:"returning"`
}

// input type for inserting object relation for remote table "accounts"
type AccountsObjRelInsertInput struct {
	Data       *AccountsInsertInput `json:"data"`
	OnConflict *AccountsOnConflict  `json:"on_conflict"`
}

// on conflict condition type for table "accounts"
type AccountsOnConflict struct {
	Constraint    AccountsConstraint     `json:"constraint"`
	UpdateColumns []AccountsUpdateColumn `json:"update_columns"`
	Where         *AccountsBoolExp       `json:"where"`
}

// ordering options when selecting data from "accounts"
type AccountsOrderBy struct {
	Email     *OrderBy      `json:"email"`
	LastLogin *OrderBy      `json:"last_login"`
	Role      *OrderBy      `json:"role"`
	User      *UsersOrderBy `json:"user"`
	UserID    *OrderBy      `json:"user_id"`
}

// primary key columns input for table: "accounts"
type AccountsPkColumnsInput struct {
	UserID string `json:"user_id"`
}

// input type for updating data in table "accounts"
type AccountsSetInput struct {
	Email     *string `json:"email"`
	LastLogin *string `json:"last_login"`
	Role      *string `json:"role"`
	UserID    *string `json:"user_id"`
}

// columns and relationships of "attendance_config"
type AttendanceConfig struct {
	FullWorkHours string `json:"full_work_hours"`
	HalfWorkHours string `json:"half_work_hours"`
	ID            string `json:"id"`
}

// aggregated selection of "attendance_config"
type AttendanceConfigAggregate struct {
	Aggregate *AttendanceConfigAggregateFields `json:"aggregate"`
	Nodes     []*AttendanceConfig              `json:"nodes"`
}

// aggregate fields of "attendance_config"
type AttendanceConfigAggregateFields struct {
	Count *int64                     `json:"count"`
	Max   *AttendanceConfigMaxFields `json:"max"`
	Min   *AttendanceConfigMinFields `json:"min"`
}

// order by aggregate values of table "attendance_config"
type AttendanceConfigAggregateOrderBy struct {
	Count *OrderBy                    `json:"count"`
	Max   *AttendanceConfigMaxOrderBy `json:"max"`
	Min   *AttendanceConfigMinOrderBy `json:"min"`
}

// input type for inserting array relation for remote table "attendance_config"
type AttendanceConfigArrRelInsertInput struct {
	Data       []*AttendanceConfigInsertInput `json:"data"`
	OnConflict *AttendanceConfigOnConflict    `json:"on_conflict"`
}

// Boolean expression to filter rows from the table "attendance_config". All fields are combined with a logical 'AND'.
type AttendanceConfigBoolExp struct {
	And           []*AttendanceConfigBoolExp `json:"_and"`
	Not           *AttendanceConfigBoolExp   `json:"_not"`
	Or            []*AttendanceConfigBoolExp `json:"_or"`
	FullWorkHours *IntervalComparisonExp     `json:"full_work_hours"`
	HalfWorkHours *IntervalComparisonExp     `json:"half_work_hours"`
	ID            *UUIDComparisonExp         `json:"id"`
}

// input type for inserting data into table "attendance_config"
type AttendanceConfigInsertInput struct {
	FullWorkHours *string `json:"full_work_hours"`
	HalfWorkHours *string `json:"half_work_hours"`
	ID            *string `json:"id"`
}

// aggregate max on columns
type AttendanceConfigMaxFields struct {
	ID *string `json:"id"`
}

// order by max() on columns of table "attendance_config"
type AttendanceConfigMaxOrderBy struct {
	ID *OrderBy `json:"id"`
}

// aggregate min on columns
type AttendanceConfigMinFields struct {
	ID *string `json:"id"`
}

// order by min() on columns of table "attendance_config"
type AttendanceConfigMinOrderBy struct {
	ID *OrderBy `json:"id"`
}

// response of any mutation on the table "attendance_config"
type AttendanceConfigMutationResponse struct {
	// number of affected rows by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data of the affected rows by the mutation
	Returning []*AttendanceConfig `json:"returning"`
}

// input type for inserting object relation for remote table "attendance_config"
type AttendanceConfigObjRelInsertInput struct {
	Data       *AttendanceConfigInsertInput `json:"data"`
	OnConflict *AttendanceConfigOnConflict  `json:"on_conflict"`
}

// on conflict condition type for table "attendance_config"
type AttendanceConfigOnConflict struct {
	Constraint    AttendanceConfigConstraint     `json:"constraint"`
	UpdateColumns []AttendanceConfigUpdateColumn `json:"update_columns"`
	Where         *AttendanceConfigBoolExp       `json:"where"`
}

// ordering options when selecting data from "attendance_config"
type AttendanceConfigOrderBy struct {
	FullWorkHours *OrderBy `json:"full_work_hours"`
	HalfWorkHours *OrderBy `json:"half_work_hours"`
	ID            *OrderBy `json:"id"`
}

// primary key columns input for table: "attendance_config"
type AttendanceConfigPkColumnsInput struct {
	ID string `json:"id"`
}

// input type for updating data in table "attendance_config"
type AttendanceConfigSetInput struct {
	FullWorkHours *string `json:"full_work_hours"`
	HalfWorkHours *string `json:"half_work_hours"`
	ID            *string `json:"id"`
}

// columns and relationships of "attendance_records"
type AttendanceRecords struct {
	AccountID            string  `json:"account_id"`
	Created              string  `json:"created"`
	ID                   string  `json:"id"`
	OnGoingHome          string  `json:"on_going_home"`
	OnGoingHomeLoc       *string `json:"on_going_home_loc"`
	OnGoingHomeTimestamp int64   `json:"on_going_home_timestamp"`
	OnGoingWork          string  `json:"on_going_work"`
	OnGoingWorkLoc       *string `json:"on_going_work_loc"`
	OnGoingWorkTimestamp int64   `json:"on_going_work_timestamp"`
	Updated              string  `json:"updated"`
}

// aggregated selection of "attendance_records"
type AttendanceRecordsAggregate struct {
	Aggregate *AttendanceRecordsAggregateFields `json:"aggregate"`
	Nodes     []*AttendanceRecords              `json:"nodes"`
}

// aggregate fields of "attendance_records"
type AttendanceRecordsAggregateFields struct {
	Avg        *AttendanceRecordsAvgFields        `json:"avg"`
	Count      *int64                             `json:"count"`
	Max        *AttendanceRecordsMaxFields        `json:"max"`
	Min        *AttendanceRecordsMinFields        `json:"min"`
	Stddev     *AttendanceRecordsStddevFields     `json:"stddev"`
	StddevPop  *AttendanceRecordsStddevPopFields  `json:"stddev_pop"`
	StddevSamp *AttendanceRecordsStddevSampFields `json:"stddev_samp"`
	Sum        *AttendanceRecordsSumFields        `json:"sum"`
	VarPop     *AttendanceRecordsVarPopFields     `json:"var_pop"`
	VarSamp    *AttendanceRecordsVarSampFields    `json:"var_samp"`
	Variance   *AttendanceRecordsVarianceFields   `json:"variance"`
}

// order by aggregate values of table "attendance_records"
type AttendanceRecordsAggregateOrderBy struct {
	Avg        *AttendanceRecordsAvgOrderBy        `json:"avg"`
	Count      *OrderBy                            `json:"count"`
	Max        *AttendanceRecordsMaxOrderBy        `json:"max"`
	Min        *AttendanceRecordsMinOrderBy        `json:"min"`
	Stddev     *AttendanceRecordsStddevOrderBy     `json:"stddev"`
	StddevPop  *AttendanceRecordsStddevPopOrderBy  `json:"stddev_pop"`
	StddevSamp *AttendanceRecordsStddevSampOrderBy `json:"stddev_samp"`
	Sum        *AttendanceRecordsSumOrderBy        `json:"sum"`
	VarPop     *AttendanceRecordsVarPopOrderBy     `json:"var_pop"`
	VarSamp    *AttendanceRecordsVarSampOrderBy    `json:"var_samp"`
	Variance   *AttendanceRecordsVarianceOrderBy   `json:"variance"`
}

// input type for inserting array relation for remote table "attendance_records"
type AttendanceRecordsArrRelInsertInput struct {
	Data       []*AttendanceRecordsInsertInput `json:"data"`
	OnConflict *AttendanceRecordsOnConflict    `json:"on_conflict"`
}

// aggregate avg on columns
type AttendanceRecordsAvgFields struct {
	OnGoingHomeTimestamp *float64 `json:"on_going_home_timestamp"`
	OnGoingWorkTimestamp *float64 `json:"on_going_work_timestamp"`
}

// order by avg() on columns of table "attendance_records"
type AttendanceRecordsAvgOrderBy struct {
	OnGoingHomeTimestamp *OrderBy `json:"on_going_home_timestamp"`
	OnGoingWorkTimestamp *OrderBy `json:"on_going_work_timestamp"`
}

// Boolean expression to filter rows from the table "attendance_records". All fields are combined with a logical 'AND'.
type AttendanceRecordsBoolExp struct {
	And                  []*AttendanceRecordsBoolExp `json:"_and"`
	Not                  *AttendanceRecordsBoolExp   `json:"_not"`
	Or                   []*AttendanceRecordsBoolExp `json:"_or"`
	AccountID            *UUIDComparisonExp          `json:"account_id"`
	Created              *TimestamptzComparisonExp   `json:"created"`
	ID                   *UUIDComparisonExp          `json:"id"`
	OnGoingHome          *StringComparisonExp        `json:"on_going_home"`
	OnGoingHomeLoc       *PointComparisonExp         `json:"on_going_home_loc"`
	OnGoingHomeTimestamp *IntComparisonExp           `json:"on_going_home_timestamp"`
	OnGoingWork          *StringComparisonExp        `json:"on_going_work"`
	OnGoingWorkLoc       *PointComparisonExp         `json:"on_going_work_loc"`
	OnGoingWorkTimestamp *IntComparisonExp           `json:"on_going_work_timestamp"`
	Updated              *TimestamptzComparisonExp   `json:"updated"`
}

// input type for incrementing integer column in table "attendance_records"
type AttendanceRecordsIncInput struct {
	OnGoingHomeTimestamp *int64 `json:"on_going_home_timestamp"`
	OnGoingWorkTimestamp *int64 `json:"on_going_work_timestamp"`
}

// input type for inserting data into table "attendance_records"
type AttendanceRecordsInsertInput struct {
	AccountID            *string `json:"account_id"`
	Created              *string `json:"created"`
	ID                   *string `json:"id"`
	OnGoingHome          *string `json:"on_going_home"`
	OnGoingHomeLoc       *string `json:"on_going_home_loc"`
	OnGoingHomeTimestamp *int64  `json:"on_going_home_timestamp"`
	OnGoingWork          *string `json:"on_going_work"`
	OnGoingWorkLoc       *string `json:"on_going_work_loc"`
	OnGoingWorkTimestamp *int64  `json:"on_going_work_timestamp"`
	Updated              *string `json:"updated"`
}

// aggregate max on columns
type AttendanceRecordsMaxFields struct {
	AccountID            *string `json:"account_id"`
	Created              *string `json:"created"`
	ID                   *string `json:"id"`
	OnGoingHome          *string `json:"on_going_home"`
	OnGoingHomeTimestamp *int64  `json:"on_going_home_timestamp"`
	OnGoingWork          *string `json:"on_going_work"`
	OnGoingWorkTimestamp *int64  `json:"on_going_work_timestamp"`
	Updated              *string `json:"updated"`
}

// order by max() on columns of table "attendance_records"
type AttendanceRecordsMaxOrderBy struct {
	AccountID            *OrderBy `json:"account_id"`
	Created              *OrderBy `json:"created"`
	ID                   *OrderBy `json:"id"`
	OnGoingHome          *OrderBy `json:"on_going_home"`
	OnGoingHomeTimestamp *OrderBy `json:"on_going_home_timestamp"`
	OnGoingWork          *OrderBy `json:"on_going_work"`
	OnGoingWorkTimestamp *OrderBy `json:"on_going_work_timestamp"`
	Updated              *OrderBy `json:"updated"`
}

// aggregate min on columns
type AttendanceRecordsMinFields struct {
	AccountID            *string `json:"account_id"`
	Created              *string `json:"created"`
	ID                   *string `json:"id"`
	OnGoingHome          *string `json:"on_going_home"`
	OnGoingHomeTimestamp *int64  `json:"on_going_home_timestamp"`
	OnGoingWork          *string `json:"on_going_work"`
	OnGoingWorkTimestamp *int64  `json:"on_going_work_timestamp"`
	Updated              *string `json:"updated"`
}

// order by min() on columns of table "attendance_records"
type AttendanceRecordsMinOrderBy struct {
	AccountID            *OrderBy `json:"account_id"`
	Created              *OrderBy `json:"created"`
	ID                   *OrderBy `json:"id"`
	OnGoingHome          *OrderBy `json:"on_going_home"`
	OnGoingHomeTimestamp *OrderBy `json:"on_going_home_timestamp"`
	OnGoingWork          *OrderBy `json:"on_going_work"`
	OnGoingWorkTimestamp *OrderBy `json:"on_going_work_timestamp"`
	Updated              *OrderBy `json:"updated"`
}

// response of any mutation on the table "attendance_records"
type AttendanceRecordsMutationResponse struct {
	// number of affected rows by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data of the affected rows by the mutation
	Returning []*AttendanceRecords `json:"returning"`
}

// input type for inserting object relation for remote table "attendance_records"
type AttendanceRecordsObjRelInsertInput struct {
	Data       *AttendanceRecordsInsertInput `json:"data"`
	OnConflict *AttendanceRecordsOnConflict  `json:"on_conflict"`
}

// on conflict condition type for table "attendance_records"
type AttendanceRecordsOnConflict struct {
	Constraint    AttendanceRecordsConstraint     `json:"constraint"`
	UpdateColumns []AttendanceRecordsUpdateColumn `json:"update_columns"`
	Where         *AttendanceRecordsBoolExp       `json:"where"`
}

// ordering options when selecting data from "attendance_records"
type AttendanceRecordsOrderBy struct {
	AccountID            *OrderBy `json:"account_id"`
	Created              *OrderBy `json:"created"`
	ID                   *OrderBy `json:"id"`
	OnGoingHome          *OrderBy `json:"on_going_home"`
	OnGoingHomeLoc       *OrderBy `json:"on_going_home_loc"`
	OnGoingHomeTimestamp *OrderBy `json:"on_going_home_timestamp"`
	OnGoingWork          *OrderBy `json:"on_going_work"`
	OnGoingWorkLoc       *OrderBy `json:"on_going_work_loc"`
	OnGoingWorkTimestamp *OrderBy `json:"on_going_work_timestamp"`
	Updated              *OrderBy `json:"updated"`
}

// primary key columns input for table: "attendance_records"
type AttendanceRecordsPkColumnsInput struct {
	ID string `json:"id"`
}

// input type for updating data in table "attendance_records"
type AttendanceRecordsSetInput struct {
	AccountID            *string `json:"account_id"`
	Created              *string `json:"created"`
	ID                   *string `json:"id"`
	OnGoingHome          *string `json:"on_going_home"`
	OnGoingHomeLoc       *string `json:"on_going_home_loc"`
	OnGoingHomeTimestamp *int64  `json:"on_going_home_timestamp"`
	OnGoingWork          *string `json:"on_going_work"`
	OnGoingWorkLoc       *string `json:"on_going_work_loc"`
	OnGoingWorkTimestamp *int64  `json:"on_going_work_timestamp"`
	Updated              *string `json:"updated"`
}

// aggregate stddev on columns
type AttendanceRecordsStddevFields struct {
	OnGoingHomeTimestamp *float64 `json:"on_going_home_timestamp"`
	OnGoingWorkTimestamp *float64 `json:"on_going_work_timestamp"`
}

// order by stddev() on columns of table "attendance_records"
type AttendanceRecordsStddevOrderBy struct {
	OnGoingHomeTimestamp *OrderBy `json:"on_going_home_timestamp"`
	OnGoingWorkTimestamp *OrderBy `json:"on_going_work_timestamp"`
}

// aggregate stddev_pop on columns
type AttendanceRecordsStddevPopFields struct {
	OnGoingHomeTimestamp *float64 `json:"on_going_home_timestamp"`
	OnGoingWorkTimestamp *float64 `json:"on_going_work_timestamp"`
}

// order by stddev_pop() on columns of table "attendance_records"
type AttendanceRecordsStddevPopOrderBy struct {
	OnGoingHomeTimestamp *OrderBy `json:"on_going_home_timestamp"`
	OnGoingWorkTimestamp *OrderBy `json:"on_going_work_timestamp"`
}

// aggregate stddev_samp on columns
type AttendanceRecordsStddevSampFields struct {
	OnGoingHomeTimestamp *float64 `json:"on_going_home_timestamp"`
	OnGoingWorkTimestamp *float64 `json:"on_going_work_timestamp"`
}

// order by stddev_samp() on columns of table "attendance_records"
type AttendanceRecordsStddevSampOrderBy struct {
	OnGoingHomeTimestamp *OrderBy `json:"on_going_home_timestamp"`
	OnGoingWorkTimestamp *OrderBy `json:"on_going_work_timestamp"`
}

// aggregate sum on columns
type AttendanceRecordsSumFields struct {
	OnGoingHomeTimestamp *int64 `json:"on_going_home_timestamp"`
	OnGoingWorkTimestamp *int64 `json:"on_going_work_timestamp"`
}

// order by sum() on columns of table "attendance_records"
type AttendanceRecordsSumOrderBy struct {
	OnGoingHomeTimestamp *OrderBy `json:"on_going_home_timestamp"`
	OnGoingWorkTimestamp *OrderBy `json:"on_going_work_timestamp"`
}

// aggregate var_pop on columns
type AttendanceRecordsVarPopFields struct {
	OnGoingHomeTimestamp *float64 `json:"on_going_home_timestamp"`
	OnGoingWorkTimestamp *float64 `json:"on_going_work_timestamp"`
}

// order by var_pop() on columns of table "attendance_records"
type AttendanceRecordsVarPopOrderBy struct {
	OnGoingHomeTimestamp *OrderBy `json:"on_going_home_timestamp"`
	OnGoingWorkTimestamp *OrderBy `json:"on_going_work_timestamp"`
}

// aggregate var_samp on columns
type AttendanceRecordsVarSampFields struct {
	OnGoingHomeTimestamp *float64 `json:"on_going_home_timestamp"`
	OnGoingWorkTimestamp *float64 `json:"on_going_work_timestamp"`
}

// order by var_samp() on columns of table "attendance_records"
type AttendanceRecordsVarSampOrderBy struct {
	OnGoingHomeTimestamp *OrderBy `json:"on_going_home_timestamp"`
	OnGoingWorkTimestamp *OrderBy `json:"on_going_work_timestamp"`
}

// aggregate variance on columns
type AttendanceRecordsVarianceFields struct {
	OnGoingHomeTimestamp *float64 `json:"on_going_home_timestamp"`
	OnGoingWorkTimestamp *float64 `json:"on_going_work_timestamp"`
}

// order by variance() on columns of table "attendance_records"
type AttendanceRecordsVarianceOrderBy struct {
	OnGoingHomeTimestamp *OrderBy `json:"on_going_home_timestamp"`
	OnGoingWorkTimestamp *OrderBy `json:"on_going_work_timestamp"`
}

// columns and relationships of "branches"
type Branches struct {
	Address     string `json:"address"`
	AreaID      string `json:"area_id"`
	City        string `json:"city"`
	CreatedDate string `json:"created_date"`
	// An object relationship
	Distributor   *Distributors `json:"distributor"`
	DistributorID string        `json:"distributor_id"`
	ID            string        `json:"id"`
	// An object relationship
	Inventory *Inventories `json:"inventory"`
	// An object relationship
	Location   *Locations `json:"location"`
	LocationID string     `json:"location_id"`
	// An object relationship
	MarketingRegion *MarketingRegions `json:"marketing_region"`
	Name            string            `json:"name"`
	Province        string            `json:"province"`
	UpdatedDate     string            `json:"updated_date"`
}

// aggregated selection of "branches"
type BranchesAggregate struct {
	Aggregate *BranchesAggregateFields `json:"aggregate"`
	Nodes     []*Branches              `json:"nodes"`
}

// aggregate fields of "branches"
type BranchesAggregateFields struct {
	Count *int64             `json:"count"`
	Max   *BranchesMaxFields `json:"max"`
	Min   *BranchesMinFields `json:"min"`
}

// order by aggregate values of table "branches"
type BranchesAggregateOrderBy struct {
	Count *OrderBy            `json:"count"`
	Max   *BranchesMaxOrderBy `json:"max"`
	Min   *BranchesMinOrderBy `json:"min"`
}

// input type for inserting array relation for remote table "branches"
type BranchesArrRelInsertInput struct {
	Data       []*BranchesInsertInput `json:"data"`
	OnConflict *BranchesOnConflict    `json:"on_conflict"`
}

// Boolean expression to filter rows from the table "branches". All fields are combined with a logical 'AND'.
type BranchesBoolExp struct {
	And             []*BranchesBoolExp       `json:"_and"`
	Not             *BranchesBoolExp         `json:"_not"`
	Or              []*BranchesBoolExp       `json:"_or"`
	Address         *StringComparisonExp     `json:"address"`
	AreaID          *UUIDComparisonExp       `json:"area_id"`
	City            *StringComparisonExp     `json:"city"`
	CreatedDate     *TimestampComparisonExp  `json:"created_date"`
	Distributor     *DistributorsBoolExp     `json:"distributor"`
	DistributorID   *UUIDComparisonExp       `json:"distributor_id"`
	ID              *UUIDComparisonExp       `json:"id"`
	Inventory       *InventoriesBoolExp      `json:"inventory"`
	Location        *LocationsBoolExp        `json:"location"`
	LocationID      *UUIDComparisonExp       `json:"location_id"`
	MarketingRegion *MarketingRegionsBoolExp `json:"marketing_region"`
	Name            *StringComparisonExp     `json:"name"`
	Province        *StringComparisonExp     `json:"province"`
	UpdatedDate     *TimestampComparisonExp  `json:"updated_date"`
}

// input type for inserting data into table "branches"
type BranchesInsertInput struct {
	Address         *string                            `json:"address"`
	AreaID          *string                            `json:"area_id"`
	City            *string                            `json:"city"`
	CreatedDate     *string                            `json:"created_date"`
	Distributor     *DistributorsObjRelInsertInput     `json:"distributor"`
	DistributorID   *string                            `json:"distributor_id"`
	ID              *string                            `json:"id"`
	Inventory       *InventoriesObjRelInsertInput      `json:"inventory"`
	Location        *LocationsObjRelInsertInput        `json:"location"`
	LocationID      *string                            `json:"location_id"`
	MarketingRegion *MarketingRegionsObjRelInsertInput `json:"marketing_region"`
	Name            *string                            `json:"name"`
	Province        *string                            `json:"province"`
	UpdatedDate     *string                            `json:"updated_date"`
}

// aggregate max on columns
type BranchesMaxFields struct {
	Address       *string `json:"address"`
	AreaID        *string `json:"area_id"`
	City          *string `json:"city"`
	CreatedDate   *string `json:"created_date"`
	DistributorID *string `json:"distributor_id"`
	ID            *string `json:"id"`
	LocationID    *string `json:"location_id"`
	Name          *string `json:"name"`
	Province      *string `json:"province"`
	UpdatedDate   *string `json:"updated_date"`
}

// order by max() on columns of table "branches"
type BranchesMaxOrderBy struct {
	Address       *OrderBy `json:"address"`
	AreaID        *OrderBy `json:"area_id"`
	City          *OrderBy `json:"city"`
	CreatedDate   *OrderBy `json:"created_date"`
	DistributorID *OrderBy `json:"distributor_id"`
	ID            *OrderBy `json:"id"`
	LocationID    *OrderBy `json:"location_id"`
	Name          *OrderBy `json:"name"`
	Province      *OrderBy `json:"province"`
	UpdatedDate   *OrderBy `json:"updated_date"`
}

// aggregate min on columns
type BranchesMinFields struct {
	Address       *string `json:"address"`
	AreaID        *string `json:"area_id"`
	City          *string `json:"city"`
	CreatedDate   *string `json:"created_date"`
	DistributorID *string `json:"distributor_id"`
	ID            *string `json:"id"`
	LocationID    *string `json:"location_id"`
	Name          *string `json:"name"`
	Province      *string `json:"province"`
	UpdatedDate   *string `json:"updated_date"`
}

// order by min() on columns of table "branches"
type BranchesMinOrderBy struct {
	Address       *OrderBy `json:"address"`
	AreaID        *OrderBy `json:"area_id"`
	City          *OrderBy `json:"city"`
	CreatedDate   *OrderBy `json:"created_date"`
	DistributorID *OrderBy `json:"distributor_id"`
	ID            *OrderBy `json:"id"`
	LocationID    *OrderBy `json:"location_id"`
	Name          *OrderBy `json:"name"`
	Province      *OrderBy `json:"province"`
	UpdatedDate   *OrderBy `json:"updated_date"`
}

// response of any mutation on the table "branches"
type BranchesMutationResponse struct {
	// number of affected rows by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data of the affected rows by the mutation
	Returning []*Branches `json:"returning"`
}

// input type for inserting object relation for remote table "branches"
type BranchesObjRelInsertInput struct {
	Data       *BranchesInsertInput `json:"data"`
	OnConflict *BranchesOnConflict  `json:"on_conflict"`
}

// on conflict condition type for table "branches"
type BranchesOnConflict struct {
	Constraint    BranchesConstraint     `json:"constraint"`
	UpdateColumns []BranchesUpdateColumn `json:"update_columns"`
	Where         *BranchesBoolExp       `json:"where"`
}

// ordering options when selecting data from "branches"
type BranchesOrderBy struct {
	Address         *OrderBy                 `json:"address"`
	AreaID          *OrderBy                 `json:"area_id"`
	City            *OrderBy                 `json:"city"`
	CreatedDate     *OrderBy                 `json:"created_date"`
	Distributor     *DistributorsOrderBy     `json:"distributor"`
	DistributorID   *OrderBy                 `json:"distributor_id"`
	ID              *OrderBy                 `json:"id"`
	Inventory       *InventoriesOrderBy      `json:"inventory"`
	Location        *LocationsOrderBy        `json:"location"`
	LocationID      *OrderBy                 `json:"location_id"`
	MarketingRegion *MarketingRegionsOrderBy `json:"marketing_region"`
	Name            *OrderBy                 `json:"name"`
	Province        *OrderBy                 `json:"province"`
	UpdatedDate     *OrderBy                 `json:"updated_date"`
}

// primary key columns input for table: "branches"
type BranchesPkColumnsInput struct {
	ID string `json:"id"`
}

// input type for updating data in table "branches"
type BranchesSetInput struct {
	Address       *string `json:"address"`
	AreaID        *string `json:"area_id"`
	City          *string `json:"city"`
	CreatedDate   *string `json:"created_date"`
	DistributorID *string `json:"distributor_id"`
	ID            *string `json:"id"`
	LocationID    *string `json:"location_id"`
	Name          *string `json:"name"`
	Province      *string `json:"province"`
	UpdatedDate   *string `json:"updated_date"`
}

// columns and relationships of "contracts"
type Contracts struct {
	ID              string `json:"id"`
	RenewalDate     string `json:"renewal_date"`
	RenewalDuration string `json:"renewal_duration"`
	StartDate       string `json:"start_date"`
	// An object relationship
	User   *Users `json:"user"`
	UserID string `json:"user_id"`
	// An array relationship
	Users []*Users `json:"users"`
	// An aggregated array relationship
	UsersAggregate *UsersAggregate `json:"users_aggregate"`
}

// aggregated selection of "contracts"
type ContractsAggregate struct {
	Aggregate *ContractsAggregateFields `json:"aggregate"`
	Nodes     []*Contracts              `json:"nodes"`
}

// aggregate fields of "contracts"
type ContractsAggregateFields struct {
	Count *int64              `json:"count"`
	Max   *ContractsMaxFields `json:"max"`
	Min   *ContractsMinFields `json:"min"`
}

// order by aggregate values of table "contracts"
type ContractsAggregateOrderBy struct {
	Count *OrderBy             `json:"count"`
	Max   *ContractsMaxOrderBy `json:"max"`
	Min   *ContractsMinOrderBy `json:"min"`
}

// input type for inserting array relation for remote table "contracts"
type ContractsArrRelInsertInput struct {
	Data       []*ContractsInsertInput `json:"data"`
	OnConflict *ContractsOnConflict    `json:"on_conflict"`
}

// Boolean expression to filter rows from the table "contracts". All fields are combined with a logical 'AND'.
type ContractsBoolExp struct {
	And             []*ContractsBoolExp `json:"_and"`
	Not             *ContractsBoolExp   `json:"_not"`
	Or              []*ContractsBoolExp `json:"_or"`
	ID              *UUIDComparisonExp  `json:"id"`
	RenewalDate     *DateComparisonExp  `json:"renewal_date"`
	RenewalDuration *DateComparisonExp  `json:"renewal_duration"`
	StartDate       *DateComparisonExp  `json:"start_date"`
	User            *UsersBoolExp       `json:"user"`
	UserID          *UUIDComparisonExp  `json:"user_id"`
	Users           *UsersBoolExp       `json:"users"`
}

// input type for inserting data into table "contracts"
type ContractsInsertInput struct {
	ID              *string                 `json:"id"`
	RenewalDate     *string                 `json:"renewal_date"`
	RenewalDuration *string                 `json:"renewal_duration"`
	StartDate       *string                 `json:"start_date"`
	User            *UsersObjRelInsertInput `json:"user"`
	UserID          *string                 `json:"user_id"`
	Users           *UsersArrRelInsertInput `json:"users"`
}

// aggregate max on columns
type ContractsMaxFields struct {
	ID              *string `json:"id"`
	RenewalDate     *string `json:"renewal_date"`
	RenewalDuration *string `json:"renewal_duration"`
	StartDate       *string `json:"start_date"`
	UserID          *string `json:"user_id"`
}

// order by max() on columns of table "contracts"
type ContractsMaxOrderBy struct {
	ID              *OrderBy `json:"id"`
	RenewalDate     *OrderBy `json:"renewal_date"`
	RenewalDuration *OrderBy `json:"renewal_duration"`
	StartDate       *OrderBy `json:"start_date"`
	UserID          *OrderBy `json:"user_id"`
}

// aggregate min on columns
type ContractsMinFields struct {
	ID              *string `json:"id"`
	RenewalDate     *string `json:"renewal_date"`
	RenewalDuration *string `json:"renewal_duration"`
	StartDate       *string `json:"start_date"`
	UserID          *string `json:"user_id"`
}

// order by min() on columns of table "contracts"
type ContractsMinOrderBy struct {
	ID              *OrderBy `json:"id"`
	RenewalDate     *OrderBy `json:"renewal_date"`
	RenewalDuration *OrderBy `json:"renewal_duration"`
	StartDate       *OrderBy `json:"start_date"`
	UserID          *OrderBy `json:"user_id"`
}

// response of any mutation on the table "contracts"
type ContractsMutationResponse struct {
	// number of affected rows by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data of the affected rows by the mutation
	Returning []*Contracts `json:"returning"`
}

// input type for inserting object relation for remote table "contracts"
type ContractsObjRelInsertInput struct {
	Data       *ContractsInsertInput `json:"data"`
	OnConflict *ContractsOnConflict  `json:"on_conflict"`
}

// on conflict condition type for table "contracts"
type ContractsOnConflict struct {
	Constraint    ContractsConstraint     `json:"constraint"`
	UpdateColumns []ContractsUpdateColumn `json:"update_columns"`
	Where         *ContractsBoolExp       `json:"where"`
}

// ordering options when selecting data from "contracts"
type ContractsOrderBy struct {
	ID              *OrderBy               `json:"id"`
	RenewalDate     *OrderBy               `json:"renewal_date"`
	RenewalDuration *OrderBy               `json:"renewal_duration"`
	StartDate       *OrderBy               `json:"start_date"`
	User            *UsersOrderBy          `json:"user"`
	UserID          *OrderBy               `json:"user_id"`
	UsersAggregate  *UsersAggregateOrderBy `json:"users_aggregate"`
}

// primary key columns input for table: "contracts"
type ContractsPkColumnsInput struct {
	ID string `json:"id"`
}

// input type for updating data in table "contracts"
type ContractsSetInput struct {
	ID              *string `json:"id"`
	RenewalDate     *string `json:"renewal_date"`
	RenewalDuration *string `json:"renewal_duration"`
	StartDate       *string `json:"start_date"`
	UserID          *string `json:"user_id"`
}

// expression to compare columns of type date. All fields are combined with logical 'AND'.
type DateComparisonExp struct {
	Eq     *string  `json:"_eq"`
	Gt     *string  `json:"_gt"`
	Gte    *string  `json:"_gte"`
	In     []string `json:"_in"`
	IsNull *bool    `json:"_is_null"`
	Lt     *string  `json:"_lt"`
	Lte    *string  `json:"_lte"`
	Neq    *string  `json:"_neq"`
	Nin    []string `json:"_nin"`
}

// columns and relationships of "distributors"
type Distributors struct {
	AreaID string `json:"area_id"`
	// An array relationship
	Branches []*Branches `json:"branches"`
	// An aggregated array relationship
	BranchesAggregate *BranchesAggregate `json:"branches_aggregate"`
	CreatedAt         string             `json:"created_at"`
	EndDate           *string            `json:"end_date"`
	HqAddress         string             `json:"hq_address"`
	HqCity            string             `json:"hq_city"`
	HqProvince        string             `json:"hq_province"`
	ID                string             `json:"id"`
	IsAssignable      bool               `json:"is_assignable"`
	IsEnabled         bool               `json:"is_enabled"`
	// An object relationship
	MarketingRegion *MarketingRegions `json:"marketing_region"`
	// An array relationship
	MateStores []*MateStores `json:"mate_stores"`
	// An aggregated array relationship
	MateStoresAggregate *MateStoresAggregate `json:"mate_stores_aggregate"`
	Name                string               `json:"name"`
	StartDate           string               `json:"start_date"`
	UpdatedAt           string               `json:"updated_at"`
}

// aggregated selection of "distributors"
type DistributorsAggregate struct {
	Aggregate *DistributorsAggregateFields `json:"aggregate"`
	Nodes     []*Distributors              `json:"nodes"`
}

// aggregate fields of "distributors"
type DistributorsAggregateFields struct {
	Count *int64                 `json:"count"`
	Max   *DistributorsMaxFields `json:"max"`
	Min   *DistributorsMinFields `json:"min"`
}

// order by aggregate values of table "distributors"
type DistributorsAggregateOrderBy struct {
	Count *OrderBy                `json:"count"`
	Max   *DistributorsMaxOrderBy `json:"max"`
	Min   *DistributorsMinOrderBy `json:"min"`
}

// input type for inserting array relation for remote table "distributors"
type DistributorsArrRelInsertInput struct {
	Data       []*DistributorsInsertInput `json:"data"`
	OnConflict *DistributorsOnConflict    `json:"on_conflict"`
}

// Boolean expression to filter rows from the table "distributors". All fields are combined with a logical 'AND'.
type DistributorsBoolExp struct {
	And             []*DistributorsBoolExp    `json:"_and"`
	Not             *DistributorsBoolExp      `json:"_not"`
	Or              []*DistributorsBoolExp    `json:"_or"`
	AreaID          *UUIDComparisonExp        `json:"area_id"`
	Branches        *BranchesBoolExp          `json:"branches"`
	CreatedAt       *TimestamptzComparisonExp `json:"created_at"`
	EndDate         *DateComparisonExp        `json:"end_date"`
	HqAddress       *StringComparisonExp      `json:"hq_address"`
	HqCity          *StringComparisonExp      `json:"hq_city"`
	HqProvince      *StringComparisonExp      `json:"hq_province"`
	ID              *UUIDComparisonExp        `json:"id"`
	IsAssignable    *BooleanComparisonExp     `json:"is_assignable"`
	IsEnabled       *BooleanComparisonExp     `json:"is_enabled"`
	MarketingRegion *MarketingRegionsBoolExp  `json:"marketing_region"`
	MateStores      *MateStoresBoolExp        `json:"mate_stores"`
	Name            *StringComparisonExp      `json:"name"`
	StartDate       *DateComparisonExp        `json:"start_date"`
	UpdatedAt       *TimestamptzComparisonExp `json:"updated_at"`
}

// input type for inserting data into table "distributors"
type DistributorsInsertInput struct {
	AreaID          *string                            `json:"area_id"`
	Branches        *BranchesArrRelInsertInput         `json:"branches"`
	CreatedAt       *string                            `json:"created_at"`
	EndDate         *string                            `json:"end_date"`
	HqAddress       *string                            `json:"hq_address"`
	HqCity          *string                            `json:"hq_city"`
	HqProvince      *string                            `json:"hq_province"`
	ID              *string                            `json:"id"`
	IsAssignable    *bool                              `json:"is_assignable"`
	IsEnabled       *bool                              `json:"is_enabled"`
	MarketingRegion *MarketingRegionsObjRelInsertInput `json:"marketing_region"`
	MateStores      *MateStoresArrRelInsertInput       `json:"mate_stores"`
	Name            *string                            `json:"name"`
	StartDate       *string                            `json:"start_date"`
	UpdatedAt       *string                            `json:"updated_at"`
}

// aggregate max on columns
type DistributorsMaxFields struct {
	AreaID     *string `json:"area_id"`
	CreatedAt  *string `json:"created_at"`
	EndDate    *string `json:"end_date"`
	HqAddress  *string `json:"hq_address"`
	HqCity     *string `json:"hq_city"`
	HqProvince *string `json:"hq_province"`
	ID         *string `json:"id"`
	Name       *string `json:"name"`
	StartDate  *string `json:"start_date"`
	UpdatedAt  *string `json:"updated_at"`
}

// order by max() on columns of table "distributors"
type DistributorsMaxOrderBy struct {
	AreaID     *OrderBy `json:"area_id"`
	CreatedAt  *OrderBy `json:"created_at"`
	EndDate    *OrderBy `json:"end_date"`
	HqAddress  *OrderBy `json:"hq_address"`
	HqCity     *OrderBy `json:"hq_city"`
	HqProvince *OrderBy `json:"hq_province"`
	ID         *OrderBy `json:"id"`
	Name       *OrderBy `json:"name"`
	StartDate  *OrderBy `json:"start_date"`
	UpdatedAt  *OrderBy `json:"updated_at"`
}

// aggregate min on columns
type DistributorsMinFields struct {
	AreaID     *string `json:"area_id"`
	CreatedAt  *string `json:"created_at"`
	EndDate    *string `json:"end_date"`
	HqAddress  *string `json:"hq_address"`
	HqCity     *string `json:"hq_city"`
	HqProvince *string `json:"hq_province"`
	ID         *string `json:"id"`
	Name       *string `json:"name"`
	StartDate  *string `json:"start_date"`
	UpdatedAt  *string `json:"updated_at"`
}

// order by min() on columns of table "distributors"
type DistributorsMinOrderBy struct {
	AreaID     *OrderBy `json:"area_id"`
	CreatedAt  *OrderBy `json:"created_at"`
	EndDate    *OrderBy `json:"end_date"`
	HqAddress  *OrderBy `json:"hq_address"`
	HqCity     *OrderBy `json:"hq_city"`
	HqProvince *OrderBy `json:"hq_province"`
	ID         *OrderBy `json:"id"`
	Name       *OrderBy `json:"name"`
	StartDate  *OrderBy `json:"start_date"`
	UpdatedAt  *OrderBy `json:"updated_at"`
}

// response of any mutation on the table "distributors"
type DistributorsMutationResponse struct {
	// number of affected rows by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data of the affected rows by the mutation
	Returning []*Distributors `json:"returning"`
}

// input type for inserting object relation for remote table "distributors"
type DistributorsObjRelInsertInput struct {
	Data       *DistributorsInsertInput `json:"data"`
	OnConflict *DistributorsOnConflict  `json:"on_conflict"`
}

// on conflict condition type for table "distributors"
type DistributorsOnConflict struct {
	Constraint    DistributorsConstraint     `json:"constraint"`
	UpdateColumns []DistributorsUpdateColumn `json:"update_columns"`
	Where         *DistributorsBoolExp       `json:"where"`
}

// ordering options when selecting data from "distributors"
type DistributorsOrderBy struct {
	AreaID              *OrderBy                    `json:"area_id"`
	BranchesAggregate   *BranchesAggregateOrderBy   `json:"branches_aggregate"`
	CreatedAt           *OrderBy                    `json:"created_at"`
	EndDate             *OrderBy                    `json:"end_date"`
	HqAddress           *OrderBy                    `json:"hq_address"`
	HqCity              *OrderBy                    `json:"hq_city"`
	HqProvince          *OrderBy                    `json:"hq_province"`
	ID                  *OrderBy                    `json:"id"`
	IsAssignable        *OrderBy                    `json:"is_assignable"`
	IsEnabled           *OrderBy                    `json:"is_enabled"`
	MarketingRegion     *MarketingRegionsOrderBy    `json:"marketing_region"`
	MateStoresAggregate *MateStoresAggregateOrderBy `json:"mate_stores_aggregate"`
	Name                *OrderBy                    `json:"name"`
	StartDate           *OrderBy                    `json:"start_date"`
	UpdatedAt           *OrderBy                    `json:"updated_at"`
}

// primary key columns input for table: "distributors"
type DistributorsPkColumnsInput struct {
	ID string `json:"id"`
}

// input type for updating data in table "distributors"
type DistributorsSetInput struct {
	AreaID       *string `json:"area_id"`
	CreatedAt    *string `json:"created_at"`
	EndDate      *string `json:"end_date"`
	HqAddress    *string `json:"hq_address"`
	HqCity       *string `json:"hq_city"`
	HqProvince   *string `json:"hq_province"`
	ID           *string `json:"id"`
	IsAssignable *bool   `json:"is_assignable"`
	IsEnabled    *bool   `json:"is_enabled"`
	Name         *string `json:"name"`
	StartDate    *string `json:"start_date"`
	UpdatedAt    *string `json:"updated_at"`
}

// columns and relationships of "distro_store_assignments"
type DistroStoreAssignments struct {
	// An object relationship
	Branch   *Branches `json:"branch"`
	BranchID *string   `json:"branch_id"`
	ID       string    `json:"id"`
	// An object relationship
	MateStore   *MateStores `json:"mate_store"`
	MateStoreID *string     `json:"mate_store_id"`
	// An object relationship
	User   *Users `json:"user"`
	UserID string `json:"user_id"`
}

// aggregated selection of "distro_store_assignments"
type DistroStoreAssignmentsAggregate struct {
	Aggregate *DistroStoreAssignmentsAggregateFields `json:"aggregate"`
	Nodes     []*DistroStoreAssignments              `json:"nodes"`
}

// aggregate fields of "distro_store_assignments"
type DistroStoreAssignmentsAggregateFields struct {
	Count *int64                           `json:"count"`
	Max   *DistroStoreAssignmentsMaxFields `json:"max"`
	Min   *DistroStoreAssignmentsMinFields `json:"min"`
}

// order by aggregate values of table "distro_store_assignments"
type DistroStoreAssignmentsAggregateOrderBy struct {
	Count *OrderBy                          `json:"count"`
	Max   *DistroStoreAssignmentsMaxOrderBy `json:"max"`
	Min   *DistroStoreAssignmentsMinOrderBy `json:"min"`
}

// input type for inserting array relation for remote table "distro_store_assignments"
type DistroStoreAssignmentsArrRelInsertInput struct {
	Data       []*DistroStoreAssignmentsInsertInput `json:"data"`
	OnConflict *DistroStoreAssignmentsOnConflict    `json:"on_conflict"`
}

// Boolean expression to filter rows from the table "distro_store_assignments". All fields are combined with a logical 'AND'.
type DistroStoreAssignmentsBoolExp struct {
	And         []*DistroStoreAssignmentsBoolExp `json:"_and"`
	Not         *DistroStoreAssignmentsBoolExp   `json:"_not"`
	Or          []*DistroStoreAssignmentsBoolExp `json:"_or"`
	Branch      *BranchesBoolExp                 `json:"branch"`
	BranchID    *UUIDComparisonExp               `json:"branch_id"`
	ID          *UUIDComparisonExp               `json:"id"`
	MateStore   *MateStoresBoolExp               `json:"mate_store"`
	MateStoreID *UUIDComparisonExp               `json:"mate_store_id"`
	User        *UsersBoolExp                    `json:"user"`
	UserID      *UUIDComparisonExp               `json:"user_id"`
}

// input type for inserting data into table "distro_store_assignments"
type DistroStoreAssignmentsInsertInput struct {
	Branch      *BranchesObjRelInsertInput   `json:"branch"`
	BranchID    *string                      `json:"branch_id"`
	ID          *string                      `json:"id"`
	MateStore   *MateStoresObjRelInsertInput `json:"mate_store"`
	MateStoreID *string                      `json:"mate_store_id"`
	User        *UsersObjRelInsertInput      `json:"user"`
	UserID      *string                      `json:"user_id"`
}

// aggregate max on columns
type DistroStoreAssignmentsMaxFields struct {
	BranchID    *string `json:"branch_id"`
	ID          *string `json:"id"`
	MateStoreID *string `json:"mate_store_id"`
	UserID      *string `json:"user_id"`
}

// order by max() on columns of table "distro_store_assignments"
type DistroStoreAssignmentsMaxOrderBy struct {
	BranchID    *OrderBy `json:"branch_id"`
	ID          *OrderBy `json:"id"`
	MateStoreID *OrderBy `json:"mate_store_id"`
	UserID      *OrderBy `json:"user_id"`
}

// aggregate min on columns
type DistroStoreAssignmentsMinFields struct {
	BranchID    *string `json:"branch_id"`
	ID          *string `json:"id"`
	MateStoreID *string `json:"mate_store_id"`
	UserID      *string `json:"user_id"`
}

// order by min() on columns of table "distro_store_assignments"
type DistroStoreAssignmentsMinOrderBy struct {
	BranchID    *OrderBy `json:"branch_id"`
	ID          *OrderBy `json:"id"`
	MateStoreID *OrderBy `json:"mate_store_id"`
	UserID      *OrderBy `json:"user_id"`
}

// response of any mutation on the table "distro_store_assignments"
type DistroStoreAssignmentsMutationResponse struct {
	// number of affected rows by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data of the affected rows by the mutation
	Returning []*DistroStoreAssignments `json:"returning"`
}

// input type for inserting object relation for remote table "distro_store_assignments"
type DistroStoreAssignmentsObjRelInsertInput struct {
	Data       *DistroStoreAssignmentsInsertInput `json:"data"`
	OnConflict *DistroStoreAssignmentsOnConflict  `json:"on_conflict"`
}

// on conflict condition type for table "distro_store_assignments"
type DistroStoreAssignmentsOnConflict struct {
	Constraint    DistroStoreAssignmentsConstraint     `json:"constraint"`
	UpdateColumns []DistroStoreAssignmentsUpdateColumn `json:"update_columns"`
	Where         *DistroStoreAssignmentsBoolExp       `json:"where"`
}

// ordering options when selecting data from "distro_store_assignments"
type DistroStoreAssignmentsOrderBy struct {
	Branch      *BranchesOrderBy   `json:"branch"`
	BranchID    *OrderBy           `json:"branch_id"`
	ID          *OrderBy           `json:"id"`
	MateStore   *MateStoresOrderBy `json:"mate_store"`
	MateStoreID *OrderBy           `json:"mate_store_id"`
	User        *UsersOrderBy      `json:"user"`
	UserID      *OrderBy           `json:"user_id"`
}

// primary key columns input for table: "distro_store_assignments"
type DistroStoreAssignmentsPkColumnsInput struct {
	ID string `json:"id"`
}

// input type for updating data in table "distro_store_assignments"
type DistroStoreAssignmentsSetInput struct {
	BranchID    *string `json:"branch_id"`
	ID          *string `json:"id"`
	MateStoreID *string `json:"mate_store_id"`
	UserID      *string `json:"user_id"`
}

// expression to compare columns of type float8. All fields are combined with logical 'AND'.
type Float8ComparisonExp struct {
	Eq     *string  `json:"_eq"`
	Gt     *string  `json:"_gt"`
	Gte    *string  `json:"_gte"`
	In     []string `json:"_in"`
	IsNull *bool    `json:"_is_null"`
	Lt     *string  `json:"_lt"`
	Lte    *string  `json:"_lte"`
	Neq    *string  `json:"_neq"`
	Nin    []string `json:"_nin"`
}

// Expression to compare the result of casting a column of type geography. Multiple cast targets are combined with logical 'AND'.
type GeographyCastExp struct {
	Geometry *GeometryComparisonExp `json:"geometry"`
}

// expression to compare columns of type geography. All fields are combined with logical 'AND'.
type GeographyComparisonExp struct {
	Cast   *GeographyCastExp `json:"_cast"`
	Eq     *string           `json:"_eq"`
	Gt     *string           `json:"_gt"`
	Gte    *string           `json:"_gte"`
	In     []string          `json:"_in"`
	IsNull *bool             `json:"_is_null"`
	Lt     *string           `json:"_lt"`
	Lte    *string           `json:"_lte"`
	Neq    *string           `json:"_neq"`
	Nin    []string          `json:"_nin"`
	// is the column within a distance from a geography value
	StDWithin *StDWithinGeographyInput `json:"_st_d_within"`
	// does the column spatially intersect the given geography value
	StIntersects *string `json:"_st_intersects"`
}

// Expression to compare the result of casting a column of type geometry. Multiple cast targets are combined with logical 'AND'.
type GeometryCastExp struct {
	Geography *GeographyComparisonExp `json:"geography"`
}

// expression to compare columns of type geometry. All fields are combined with logical 'AND'.
type GeometryComparisonExp struct {
	Cast   *GeometryCastExp `json:"_cast"`
	Eq     *string          `json:"_eq"`
	Gt     *string          `json:"_gt"`
	Gte    *string          `json:"_gte"`
	In     []string         `json:"_in"`
	IsNull *bool            `json:"_is_null"`
	Lt     *string          `json:"_lt"`
	Lte    *string          `json:"_lte"`
	Neq    *string          `json:"_neq"`
	Nin    []string         `json:"_nin"`
	// does the column contain the given geometry value
	StContains *string `json:"_st_contains"`
	// does the column crosses the given geometry value
	StCrosses *string `json:"_st_crosses"`
	// is the column within a distance from a geometry value
	StDWithin *StDWithinInput `json:"_st_d_within"`
	// is the column equal to given geometry value. Directionality is ignored
	StEquals *string `json:"_st_equals"`
	// does the column spatially intersect the given geometry value
	StIntersects *string `json:"_st_intersects"`
	// does the column 'spatially overlap' (intersect but not completely contain) the given geometry value
	StOverlaps *string `json:"_st_overlaps"`
	// does the column have atleast one point in common with the given geometry value
	StTouches *string `json:"_st_touches"`
	// is the column contained in the given geometry value
	StWithin *string `json:"_st_within"`
}

type GetSessionRoleArgs struct {
	HasuraSession *string `json:"hasura_session"`
}

// expression to compare columns of type interval. All fields are combined with logical 'AND'.
type IntervalComparisonExp struct {
	Eq     *string  `json:"_eq"`
	Gt     *string  `json:"_gt"`
	Gte    *string  `json:"_gte"`
	In     []string `json:"_in"`
	IsNull *bool    `json:"_is_null"`
	Lt     *string  `json:"_lt"`
	Lte    *string  `json:"_lte"`
	Neq    *string  `json:"_neq"`
	Nin    []string `json:"_nin"`
}

// columns and relationships of "inventories"
type Inventories struct {
	ArrivalDate string `json:"arrival_date"`
	// An object relationship
	Branch     *Branches `json:"branch"`
	BranchID   string    `json:"branch_id"`
	ExpiryDate string    `json:"expiry_date"`
	ID         string    `json:"id"`
	// An object relationship
	MateStore   *MateStores `json:"mate_store"`
	MateStoreID string      `json:"mate_store_id"`
	// An object relationship
	Product   *Products `json:"product"`
	ProductID string    `json:"product_id"`
	Qty       string    `json:"qty"`
}

// aggregated selection of "inventories"
type InventoriesAggregate struct {
	Aggregate *InventoriesAggregateFields `json:"aggregate"`
	Nodes     []*Inventories              `json:"nodes"`
}

// aggregate fields of "inventories"
type InventoriesAggregateFields struct {
	Avg        *InventoriesAvgFields        `json:"avg"`
	Count      *int64                       `json:"count"`
	Max        *InventoriesMaxFields        `json:"max"`
	Min        *InventoriesMinFields        `json:"min"`
	Stddev     *InventoriesStddevFields     `json:"stddev"`
	StddevPop  *InventoriesStddevPopFields  `json:"stddev_pop"`
	StddevSamp *InventoriesStddevSampFields `json:"stddev_samp"`
	Sum        *InventoriesSumFields        `json:"sum"`
	VarPop     *InventoriesVarPopFields     `json:"var_pop"`
	VarSamp    *InventoriesVarSampFields    `json:"var_samp"`
	Variance   *InventoriesVarianceFields   `json:"variance"`
}

// order by aggregate values of table "inventories"
type InventoriesAggregateOrderBy struct {
	Avg        *InventoriesAvgOrderBy        `json:"avg"`
	Count      *OrderBy                      `json:"count"`
	Max        *InventoriesMaxOrderBy        `json:"max"`
	Min        *InventoriesMinOrderBy        `json:"min"`
	Stddev     *InventoriesStddevOrderBy     `json:"stddev"`
	StddevPop  *InventoriesStddevPopOrderBy  `json:"stddev_pop"`
	StddevSamp *InventoriesStddevSampOrderBy `json:"stddev_samp"`
	Sum        *InventoriesSumOrderBy        `json:"sum"`
	VarPop     *InventoriesVarPopOrderBy     `json:"var_pop"`
	VarSamp    *InventoriesVarSampOrderBy    `json:"var_samp"`
	Variance   *InventoriesVarianceOrderBy   `json:"variance"`
}

// input type for inserting array relation for remote table "inventories"
type InventoriesArrRelInsertInput struct {
	Data       []*InventoriesInsertInput `json:"data"`
	OnConflict *InventoriesOnConflict    `json:"on_conflict"`
}

// aggregate avg on columns
type InventoriesAvgFields struct {
	Qty *float64 `json:"qty"`
}

// order by avg() on columns of table "inventories"
type InventoriesAvgOrderBy struct {
	Qty *OrderBy `json:"qty"`
}

// Boolean expression to filter rows from the table "inventories". All fields are combined with a logical 'AND'.
type InventoriesBoolExp struct {
	And         []*InventoriesBoolExp `json:"_and"`
	Not         *InventoriesBoolExp   `json:"_not"`
	Or          []*InventoriesBoolExp `json:"_or"`
	ArrivalDate *DateComparisonExp    `json:"arrival_date"`
	Branch      *BranchesBoolExp      `json:"branch"`
	BranchID    *UUIDComparisonExp    `json:"branch_id"`
	ExpiryDate  *DateComparisonExp    `json:"expiry_date"`
	ID          *UUIDComparisonExp    `json:"id"`
	MateStore   *MateStoresBoolExp    `json:"mate_store"`
	MateStoreID *UUIDComparisonExp    `json:"mate_store_id"`
	Product     *ProductsBoolExp      `json:"product"`
	ProductID   *UUIDComparisonExp    `json:"product_id"`
	Qty         *Float8ComparisonExp  `json:"qty"`
}

// input type for incrementing integer column in table "inventories"
type InventoriesIncInput struct {
	Qty *string `json:"qty"`
}

// input type for inserting data into table "inventories"
type InventoriesInsertInput struct {
	ArrivalDate *string                      `json:"arrival_date"`
	Branch      *BranchesObjRelInsertInput   `json:"branch"`
	BranchID    *string                      `json:"branch_id"`
	ExpiryDate  *string                      `json:"expiry_date"`
	ID          *string                      `json:"id"`
	MateStore   *MateStoresObjRelInsertInput `json:"mate_store"`
	MateStoreID *string                      `json:"mate_store_id"`
	Product     *ProductsObjRelInsertInput   `json:"product"`
	ProductID   *string                      `json:"product_id"`
	Qty         *string                      `json:"qty"`
}

// aggregate max on columns
type InventoriesMaxFields struct {
	ArrivalDate *string `json:"arrival_date"`
	BranchID    *string `json:"branch_id"`
	ExpiryDate  *string `json:"expiry_date"`
	ID          *string `json:"id"`
	MateStoreID *string `json:"mate_store_id"`
	ProductID   *string `json:"product_id"`
	Qty         *string `json:"qty"`
}

// order by max() on columns of table "inventories"
type InventoriesMaxOrderBy struct {
	ArrivalDate *OrderBy `json:"arrival_date"`
	BranchID    *OrderBy `json:"branch_id"`
	ExpiryDate  *OrderBy `json:"expiry_date"`
	ID          *OrderBy `json:"id"`
	MateStoreID *OrderBy `json:"mate_store_id"`
	ProductID   *OrderBy `json:"product_id"`
	Qty         *OrderBy `json:"qty"`
}

// aggregate min on columns
type InventoriesMinFields struct {
	ArrivalDate *string `json:"arrival_date"`
	BranchID    *string `json:"branch_id"`
	ExpiryDate  *string `json:"expiry_date"`
	ID          *string `json:"id"`
	MateStoreID *string `json:"mate_store_id"`
	ProductID   *string `json:"product_id"`
	Qty         *string `json:"qty"`
}

// order by min() on columns of table "inventories"
type InventoriesMinOrderBy struct {
	ArrivalDate *OrderBy `json:"arrival_date"`
	BranchID    *OrderBy `json:"branch_id"`
	ExpiryDate  *OrderBy `json:"expiry_date"`
	ID          *OrderBy `json:"id"`
	MateStoreID *OrderBy `json:"mate_store_id"`
	ProductID   *OrderBy `json:"product_id"`
	Qty         *OrderBy `json:"qty"`
}

// response of any mutation on the table "inventories"
type InventoriesMutationResponse struct {
	// number of affected rows by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data of the affected rows by the mutation
	Returning []*Inventories `json:"returning"`
}

// input type for inserting object relation for remote table "inventories"
type InventoriesObjRelInsertInput struct {
	Data       *InventoriesInsertInput `json:"data"`
	OnConflict *InventoriesOnConflict  `json:"on_conflict"`
}

// on conflict condition type for table "inventories"
type InventoriesOnConflict struct {
	Constraint    InventoriesConstraint     `json:"constraint"`
	UpdateColumns []InventoriesUpdateColumn `json:"update_columns"`
	Where         *InventoriesBoolExp       `json:"where"`
}

// ordering options when selecting data from "inventories"
type InventoriesOrderBy struct {
	ArrivalDate *OrderBy           `json:"arrival_date"`
	Branch      *BranchesOrderBy   `json:"branch"`
	BranchID    *OrderBy           `json:"branch_id"`
	ExpiryDate  *OrderBy           `json:"expiry_date"`
	ID          *OrderBy           `json:"id"`
	MateStore   *MateStoresOrderBy `json:"mate_store"`
	MateStoreID *OrderBy           `json:"mate_store_id"`
	Product     *ProductsOrderBy   `json:"product"`
	ProductID   *OrderBy           `json:"product_id"`
	Qty         *OrderBy           `json:"qty"`
}

// primary key columns input for table: "inventories"
type InventoriesPkColumnsInput struct {
	ID string `json:"id"`
}

// input type for updating data in table "inventories"
type InventoriesSetInput struct {
	ArrivalDate *string `json:"arrival_date"`
	BranchID    *string `json:"branch_id"`
	ExpiryDate  *string `json:"expiry_date"`
	ID          *string `json:"id"`
	MateStoreID *string `json:"mate_store_id"`
	ProductID   *string `json:"product_id"`
	Qty         *string `json:"qty"`
}

// aggregate stddev on columns
type InventoriesStddevFields struct {
	Qty *float64 `json:"qty"`
}

// order by stddev() on columns of table "inventories"
type InventoriesStddevOrderBy struct {
	Qty *OrderBy `json:"qty"`
}

// aggregate stddev_pop on columns
type InventoriesStddevPopFields struct {
	Qty *float64 `json:"qty"`
}

// order by stddev_pop() on columns of table "inventories"
type InventoriesStddevPopOrderBy struct {
	Qty *OrderBy `json:"qty"`
}

// aggregate stddev_samp on columns
type InventoriesStddevSampFields struct {
	Qty *float64 `json:"qty"`
}

// order by stddev_samp() on columns of table "inventories"
type InventoriesStddevSampOrderBy struct {
	Qty *OrderBy `json:"qty"`
}

// aggregate sum on columns
type InventoriesSumFields struct {
	Qty *string `json:"qty"`
}

// order by sum() on columns of table "inventories"
type InventoriesSumOrderBy struct {
	Qty *OrderBy `json:"qty"`
}

// aggregate var_pop on columns
type InventoriesVarPopFields struct {
	Qty *float64 `json:"qty"`
}

// order by var_pop() on columns of table "inventories"
type InventoriesVarPopOrderBy struct {
	Qty *OrderBy `json:"qty"`
}

// aggregate var_samp on columns
type InventoriesVarSampFields struct {
	Qty *float64 `json:"qty"`
}

// order by var_samp() on columns of table "inventories"
type InventoriesVarSampOrderBy struct {
	Qty *OrderBy `json:"qty"`
}

// aggregate variance on columns
type InventoriesVarianceFields struct {
	Qty *float64 `json:"qty"`
}

// order by variance() on columns of table "inventories"
type InventoriesVarianceOrderBy struct {
	Qty *OrderBy `json:"qty"`
}

// expression to compare columns of type jsonb. All fields are combined with logical 'AND'.
type JsonbComparisonExp struct {
	// is the column contained in the given json value
	ContainedIn *string `json:"_contained_in"`
	// does the column contain the given json value at the top level
	Contains *string `json:"_contains"`
	Eq       *string `json:"_eq"`
	Gt       *string `json:"_gt"`
	Gte      *string `json:"_gte"`
	// does the string exist as a top-level key in the column
	HasKey *string `json:"_has_key"`
	// do all of these strings exist as top-level keys in the column
	HasKeysAll []string `json:"_has_keys_all"`
	// do any of these strings exist as top-level keys in the column
	HasKeysAny []string `json:"_has_keys_any"`
	In         []string `json:"_in"`
	IsNull     *bool    `json:"_is_null"`
	Lt         *string  `json:"_lt"`
	Lte        *string  `json:"_lte"`
	Neq        *string  `json:"_neq"`
	Nin        []string `json:"_nin"`
}

// columns and relationships of "locations"
type Locations struct {
	// An array relationship
	Branches []*Branches `json:"branches"`
	// An aggregated array relationship
	BranchesAggregate *BranchesAggregate `json:"branches_aggregate"`
	GeoLoc            *string            `json:"geo_loc"`
	ID                string             `json:"id"`
	// An array relationship
	MateStores []*MateStores `json:"mate_stores"`
	// An aggregated array relationship
	MateStoresAggregate *MateStoresAggregate `json:"mate_stores_aggregate"`
	Name                *string              `json:"name"`
}

// aggregated selection of "locations"
type LocationsAggregate struct {
	Aggregate *LocationsAggregateFields `json:"aggregate"`
	Nodes     []*Locations              `json:"nodes"`
}

// aggregate fields of "locations"
type LocationsAggregateFields struct {
	Count *int64              `json:"count"`
	Max   *LocationsMaxFields `json:"max"`
	Min   *LocationsMinFields `json:"min"`
}

// order by aggregate values of table "locations"
type LocationsAggregateOrderBy struct {
	Count *OrderBy             `json:"count"`
	Max   *LocationsMaxOrderBy `json:"max"`
	Min   *LocationsMinOrderBy `json:"min"`
}

// input type for inserting array relation for remote table "locations"
type LocationsArrRelInsertInput struct {
	Data       []*LocationsInsertInput `json:"data"`
	OnConflict *LocationsOnConflict    `json:"on_conflict"`
}

// Boolean expression to filter rows from the table "locations". All fields are combined with a logical 'AND'.
type LocationsBoolExp struct {
	And        []*LocationsBoolExp    `json:"_and"`
	Not        *LocationsBoolExp      `json:"_not"`
	Or         []*LocationsBoolExp    `json:"_or"`
	Branches   *BranchesBoolExp       `json:"branches"`
	GeoLoc     *GeometryComparisonExp `json:"geo_loc"`
	ID         *UUIDComparisonExp     `json:"id"`
	MateStores *MateStoresBoolExp     `json:"mate_stores"`
	Name       *StringComparisonExp   `json:"name"`
}

// input type for inserting data into table "locations"
type LocationsInsertInput struct {
	Branches   *BranchesArrRelInsertInput   `json:"branches"`
	GeoLoc     *string                      `json:"geo_loc"`
	ID         *string                      `json:"id"`
	MateStores *MateStoresArrRelInsertInput `json:"mate_stores"`
	Name       *string                      `json:"name"`
}

// aggregate max on columns
type LocationsMaxFields struct {
	ID   *string `json:"id"`
	Name *string `json:"name"`
}

// order by max() on columns of table "locations"
type LocationsMaxOrderBy struct {
	ID   *OrderBy `json:"id"`
	Name *OrderBy `json:"name"`
}

// aggregate min on columns
type LocationsMinFields struct {
	ID   *string `json:"id"`
	Name *string `json:"name"`
}

// order by min() on columns of table "locations"
type LocationsMinOrderBy struct {
	ID   *OrderBy `json:"id"`
	Name *OrderBy `json:"name"`
}

// response of any mutation on the table "locations"
type LocationsMutationResponse struct {
	// number of affected rows by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data of the affected rows by the mutation
	Returning []*Locations `json:"returning"`
}

// input type for inserting object relation for remote table "locations"
type LocationsObjRelInsertInput struct {
	Data       *LocationsInsertInput `json:"data"`
	OnConflict *LocationsOnConflict  `json:"on_conflict"`
}

// on conflict condition type for table "locations"
type LocationsOnConflict struct {
	Constraint    LocationsConstraint     `json:"constraint"`
	UpdateColumns []LocationsUpdateColumn `json:"update_columns"`
	Where         *LocationsBoolExp       `json:"where"`
}

// ordering options when selecting data from "locations"
type LocationsOrderBy struct {
	BranchesAggregate   *BranchesAggregateOrderBy   `json:"branches_aggregate"`
	GeoLoc              *OrderBy                    `json:"geo_loc"`
	ID                  *OrderBy                    `json:"id"`
	MateStoresAggregate *MateStoresAggregateOrderBy `json:"mate_stores_aggregate"`
	Name                *OrderBy                    `json:"name"`
}

// primary key columns input for table: "locations"
type LocationsPkColumnsInput struct {
	ID string `json:"id"`
}

// input type for updating data in table "locations"
type LocationsSetInput struct {
	GeoLoc *string `json:"geo_loc"`
	ID     *string `json:"id"`
	Name   *string `json:"name"`
}

// columns and relationships of "marketing_regions"
type MarketingRegions struct {
	// An array relationship
	Branches []*Branches `json:"branches"`
	// An aggregated array relationship
	BranchesAggregate *BranchesAggregate `json:"branches_aggregate"`
	// An array relationship
	Distributors []*Distributors `json:"distributors"`
	// An aggregated array relationship
	DistributorsAggregate *DistributorsAggregate `json:"distributors_aggregate"`
	ID                    string                 `json:"id"`
	Notes                 string                 `json:"notes"`
	RegionCode            string                 `json:"region_code"`
}

// aggregated selection of "marketing_regions"
type MarketingRegionsAggregate struct {
	Aggregate *MarketingRegionsAggregateFields `json:"aggregate"`
	Nodes     []*MarketingRegions              `json:"nodes"`
}

// aggregate fields of "marketing_regions"
type MarketingRegionsAggregateFields struct {
	Count *int64                     `json:"count"`
	Max   *MarketingRegionsMaxFields `json:"max"`
	Min   *MarketingRegionsMinFields `json:"min"`
}

// order by aggregate values of table "marketing_regions"
type MarketingRegionsAggregateOrderBy struct {
	Count *OrderBy                    `json:"count"`
	Max   *MarketingRegionsMaxOrderBy `json:"max"`
	Min   *MarketingRegionsMinOrderBy `json:"min"`
}

// input type for inserting array relation for remote table "marketing_regions"
type MarketingRegionsArrRelInsertInput struct {
	Data       []*MarketingRegionsInsertInput `json:"data"`
	OnConflict *MarketingRegionsOnConflict    `json:"on_conflict"`
}

// Boolean expression to filter rows from the table "marketing_regions". All fields are combined with a logical 'AND'.
type MarketingRegionsBoolExp struct {
	And          []*MarketingRegionsBoolExp `json:"_and"`
	Not          *MarketingRegionsBoolExp   `json:"_not"`
	Or           []*MarketingRegionsBoolExp `json:"_or"`
	Branches     *BranchesBoolExp           `json:"branches"`
	Distributors *DistributorsBoolExp       `json:"distributors"`
	ID           *UUIDComparisonExp         `json:"id"`
	Notes        *StringComparisonExp       `json:"notes"`
	RegionCode   *StringComparisonExp       `json:"region_code"`
}

// input type for inserting data into table "marketing_regions"
type MarketingRegionsInsertInput struct {
	Branches     *BranchesArrRelInsertInput     `json:"branches"`
	Distributors *DistributorsArrRelInsertInput `json:"distributors"`
	ID           *string                        `json:"id"`
	Notes        *string                        `json:"notes"`
	RegionCode   *string                        `json:"region_code"`
}

// aggregate max on columns
type MarketingRegionsMaxFields struct {
	ID         *string `json:"id"`
	Notes      *string `json:"notes"`
	RegionCode *string `json:"region_code"`
}

// order by max() on columns of table "marketing_regions"
type MarketingRegionsMaxOrderBy struct {
	ID         *OrderBy `json:"id"`
	Notes      *OrderBy `json:"notes"`
	RegionCode *OrderBy `json:"region_code"`
}

// aggregate min on columns
type MarketingRegionsMinFields struct {
	ID         *string `json:"id"`
	Notes      *string `json:"notes"`
	RegionCode *string `json:"region_code"`
}

// order by min() on columns of table "marketing_regions"
type MarketingRegionsMinOrderBy struct {
	ID         *OrderBy `json:"id"`
	Notes      *OrderBy `json:"notes"`
	RegionCode *OrderBy `json:"region_code"`
}

// response of any mutation on the table "marketing_regions"
type MarketingRegionsMutationResponse struct {
	// number of affected rows by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data of the affected rows by the mutation
	Returning []*MarketingRegions `json:"returning"`
}

// input type for inserting object relation for remote table "marketing_regions"
type MarketingRegionsObjRelInsertInput struct {
	Data       *MarketingRegionsInsertInput `json:"data"`
	OnConflict *MarketingRegionsOnConflict  `json:"on_conflict"`
}

// on conflict condition type for table "marketing_regions"
type MarketingRegionsOnConflict struct {
	Constraint    MarketingRegionsConstraint     `json:"constraint"`
	UpdateColumns []MarketingRegionsUpdateColumn `json:"update_columns"`
	Where         *MarketingRegionsBoolExp       `json:"where"`
}

// ordering options when selecting data from "marketing_regions"
type MarketingRegionsOrderBy struct {
	BranchesAggregate     *BranchesAggregateOrderBy     `json:"branches_aggregate"`
	DistributorsAggregate *DistributorsAggregateOrderBy `json:"distributors_aggregate"`
	ID                    *OrderBy                      `json:"id"`
	Notes                 *OrderBy                      `json:"notes"`
	RegionCode            *OrderBy                      `json:"region_code"`
}

// primary key columns input for table: "marketing_regions"
type MarketingRegionsPkColumnsInput struct {
	ID string `json:"id"`
}

// input type for updating data in table "marketing_regions"
type MarketingRegionsSetInput struct {
	ID         *string `json:"id"`
	Notes      *string `json:"notes"`
	RegionCode *string `json:"region_code"`
}

// columns and relationships of "mate_stores"
type MateStores struct {
	Address string `json:"address"`
	// An object relationship
	Assignment *DistroStoreAssignments `json:"assignment"`
	City       string                  `json:"city"`
	CreatedAt  string                  `json:"created_at"`
	EndDate    *string                 `json:"end_date"`
	ID         string                  `json:"id"`
	// An array relationship
	Inventories []*Inventories `json:"inventories"`
	// An aggregated array relationship
	InventoriesAggregate *InventoriesAggregate `json:"inventories_aggregate"`
	IsEnabled            bool                  `json:"is_enabled"`
	// An object relationship
	Location   *Locations `json:"location"`
	LocationID string     `json:"location_id"`
	Name       string     `json:"name"`
	Province   string     `json:"province"`
	StartDate  string     `json:"start_date"`
	// An object relationship
	Supplier   *Distributors `json:"supplier"`
	SupplierID string        `json:"supplier_id"`
	UpdatedAt  *string       `json:"updated_at"`
}

// aggregated selection of "mate_stores"
type MateStoresAggregate struct {
	Aggregate *MateStoresAggregateFields `json:"aggregate"`
	Nodes     []*MateStores              `json:"nodes"`
}

// aggregate fields of "mate_stores"
type MateStoresAggregateFields struct {
	Count *int64               `json:"count"`
	Max   *MateStoresMaxFields `json:"max"`
	Min   *MateStoresMinFields `json:"min"`
}

// order by aggregate values of table "mate_stores"
type MateStoresAggregateOrderBy struct {
	Count *OrderBy              `json:"count"`
	Max   *MateStoresMaxOrderBy `json:"max"`
	Min   *MateStoresMinOrderBy `json:"min"`
}

// input type for inserting array relation for remote table "mate_stores"
type MateStoresArrRelInsertInput struct {
	Data       []*MateStoresInsertInput `json:"data"`
	OnConflict *MateStoresOnConflict    `json:"on_conflict"`
}

// Boolean expression to filter rows from the table "mate_stores". All fields are combined with a logical 'AND'.
type MateStoresBoolExp struct {
	And         []*MateStoresBoolExp           `json:"_and"`
	Not         *MateStoresBoolExp             `json:"_not"`
	Or          []*MateStoresBoolExp           `json:"_or"`
	Address     *StringComparisonExp           `json:"address"`
	Assignment  *DistroStoreAssignmentsBoolExp `json:"assignment"`
	City        *StringComparisonExp           `json:"city"`
	CreatedAt   *TimestamptzComparisonExp      `json:"created_at"`
	EndDate     *DateComparisonExp             `json:"end_date"`
	ID          *UUIDComparisonExp             `json:"id"`
	Inventories *InventoriesBoolExp            `json:"inventories"`
	IsEnabled   *BooleanComparisonExp          `json:"is_enabled"`
	Location    *LocationsBoolExp              `json:"location"`
	LocationID  *UUIDComparisonExp             `json:"location_id"`
	Name        *StringComparisonExp           `json:"name"`
	Province    *StringComparisonExp           `json:"province"`
	StartDate   *DateComparisonExp             `json:"start_date"`
	Supplier    *DistributorsBoolExp           `json:"supplier"`
	SupplierID  *UUIDComparisonExp             `json:"supplier_id"`
	UpdatedAt   *TimestamptzComparisonExp      `json:"updated_at"`
}

// input type for inserting data into table "mate_stores"
type MateStoresInsertInput struct {
	Address     *string                                  `json:"address"`
	Assignment  *DistroStoreAssignmentsObjRelInsertInput `json:"assignment"`
	City        *string                                  `json:"city"`
	CreatedAt   *string                                  `json:"created_at"`
	EndDate     *string                                  `json:"end_date"`
	ID          *string                                  `json:"id"`
	Inventories *InventoriesArrRelInsertInput            `json:"inventories"`
	IsEnabled   *bool                                    `json:"is_enabled"`
	Location    *LocationsObjRelInsertInput              `json:"location"`
	LocationID  *string                                  `json:"location_id"`
	Name        *string                                  `json:"name"`
	Province    *string                                  `json:"province"`
	StartDate   *string                                  `json:"start_date"`
	Supplier    *DistributorsObjRelInsertInput           `json:"supplier"`
	SupplierID  *string                                  `json:"supplier_id"`
	UpdatedAt   *string                                  `json:"updated_at"`
}

// aggregate max on columns
type MateStoresMaxFields struct {
	Address    *string `json:"address"`
	City       *string `json:"city"`
	CreatedAt  *string `json:"created_at"`
	EndDate    *string `json:"end_date"`
	ID         *string `json:"id"`
	LocationID *string `json:"location_id"`
	Name       *string `json:"name"`
	Province   *string `json:"province"`
	StartDate  *string `json:"start_date"`
	SupplierID *string `json:"supplier_id"`
	UpdatedAt  *string `json:"updated_at"`
}

// order by max() on columns of table "mate_stores"
type MateStoresMaxOrderBy struct {
	Address    *OrderBy `json:"address"`
	City       *OrderBy `json:"city"`
	CreatedAt  *OrderBy `json:"created_at"`
	EndDate    *OrderBy `json:"end_date"`
	ID         *OrderBy `json:"id"`
	LocationID *OrderBy `json:"location_id"`
	Name       *OrderBy `json:"name"`
	Province   *OrderBy `json:"province"`
	StartDate  *OrderBy `json:"start_date"`
	SupplierID *OrderBy `json:"supplier_id"`
	UpdatedAt  *OrderBy `json:"updated_at"`
}

// aggregate min on columns
type MateStoresMinFields struct {
	Address    *string `json:"address"`
	City       *string `json:"city"`
	CreatedAt  *string `json:"created_at"`
	EndDate    *string `json:"end_date"`
	ID         *string `json:"id"`
	LocationID *string `json:"location_id"`
	Name       *string `json:"name"`
	Province   *string `json:"province"`
	StartDate  *string `json:"start_date"`
	SupplierID *string `json:"supplier_id"`
	UpdatedAt  *string `json:"updated_at"`
}

// order by min() on columns of table "mate_stores"
type MateStoresMinOrderBy struct {
	Address    *OrderBy `json:"address"`
	City       *OrderBy `json:"city"`
	CreatedAt  *OrderBy `json:"created_at"`
	EndDate    *OrderBy `json:"end_date"`
	ID         *OrderBy `json:"id"`
	LocationID *OrderBy `json:"location_id"`
	Name       *OrderBy `json:"name"`
	Province   *OrderBy `json:"province"`
	StartDate  *OrderBy `json:"start_date"`
	SupplierID *OrderBy `json:"supplier_id"`
	UpdatedAt  *OrderBy `json:"updated_at"`
}

// response of any mutation on the table "mate_stores"
type MateStoresMutationResponse struct {
	// number of affected rows by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data of the affected rows by the mutation
	Returning []*MateStores `json:"returning"`
}

// input type for inserting object relation for remote table "mate_stores"
type MateStoresObjRelInsertInput struct {
	Data       *MateStoresInsertInput `json:"data"`
	OnConflict *MateStoresOnConflict  `json:"on_conflict"`
}

// on conflict condition type for table "mate_stores"
type MateStoresOnConflict struct {
	Constraint    MateStoresConstraint     `json:"constraint"`
	UpdateColumns []MateStoresUpdateColumn `json:"update_columns"`
	Where         *MateStoresBoolExp       `json:"where"`
}

// ordering options when selecting data from "mate_stores"
type MateStoresOrderBy struct {
	Address              *OrderBy                       `json:"address"`
	Assignment           *DistroStoreAssignmentsOrderBy `json:"assignment"`
	City                 *OrderBy                       `json:"city"`
	CreatedAt            *OrderBy                       `json:"created_at"`
	EndDate              *OrderBy                       `json:"end_date"`
	ID                   *OrderBy                       `json:"id"`
	InventoriesAggregate *InventoriesAggregateOrderBy   `json:"inventories_aggregate"`
	IsEnabled            *OrderBy                       `json:"is_enabled"`
	Location             *LocationsOrderBy              `json:"location"`
	LocationID           *OrderBy                       `json:"location_id"`
	Name                 *OrderBy                       `json:"name"`
	Province             *OrderBy                       `json:"province"`
	StartDate            *OrderBy                       `json:"start_date"`
	Supplier             *DistributorsOrderBy           `json:"supplier"`
	SupplierID           *OrderBy                       `json:"supplier_id"`
	UpdatedAt            *OrderBy                       `json:"updated_at"`
}

// primary key columns input for table: "mate_stores"
type MateStoresPkColumnsInput struct {
	ID string `json:"id"`
}

// input type for updating data in table "mate_stores"
type MateStoresSetInput struct {
	Address    *string `json:"address"`
	City       *string `json:"city"`
	CreatedAt  *string `json:"created_at"`
	EndDate    *string `json:"end_date"`
	ID         *string `json:"id"`
	IsEnabled  *bool   `json:"is_enabled"`
	LocationID *string `json:"location_id"`
	Name       *string `json:"name"`
	Province   *string `json:"province"`
	StartDate  *string `json:"start_date"`
	SupplierID *string `json:"supplier_id"`
	UpdatedAt  *string `json:"updated_at"`
}

// expression to compare columns of type point. All fields are combined with logical 'AND'.
type PointComparisonExp struct {
	Eq     *string  `json:"_eq"`
	Gt     *string  `json:"_gt"`
	Gte    *string  `json:"_gte"`
	In     []string `json:"_in"`
	IsNull *bool    `json:"_is_null"`
	Lt     *string  `json:"_lt"`
	Lte    *string  `json:"_lte"`
	Neq    *string  `json:"_neq"`
	Nin    []string `json:"_nin"`
}

// columns and relationships of "product_categories"
type ProductCategories struct {
	ID   string `json:"id"`
	Name string `json:"name"`
	// An array relationship
	Products []*Products `json:"products"`
	// An aggregated array relationship
	ProductsAggregate *ProductsAggregate `json:"products_aggregate"`
}

// aggregated selection of "product_categories"
type ProductCategoriesAggregate struct {
	Aggregate *ProductCategoriesAggregateFields `json:"aggregate"`
	Nodes     []*ProductCategories              `json:"nodes"`
}

// aggregate fields of "product_categories"
type ProductCategoriesAggregateFields struct {
	Count *int64                      `json:"count"`
	Max   *ProductCategoriesMaxFields `json:"max"`
	Min   *ProductCategoriesMinFields `json:"min"`
}

// order by aggregate values of table "product_categories"
type ProductCategoriesAggregateOrderBy struct {
	Count *OrderBy                     `json:"count"`
	Max   *ProductCategoriesMaxOrderBy `json:"max"`
	Min   *ProductCategoriesMinOrderBy `json:"min"`
}

// input type for inserting array relation for remote table "product_categories"
type ProductCategoriesArrRelInsertInput struct {
	Data       []*ProductCategoriesInsertInput `json:"data"`
	OnConflict *ProductCategoriesOnConflict    `json:"on_conflict"`
}

// Boolean expression to filter rows from the table "product_categories". All fields are combined with a logical 'AND'.
type ProductCategoriesBoolExp struct {
	And      []*ProductCategoriesBoolExp `json:"_and"`
	Not      *ProductCategoriesBoolExp   `json:"_not"`
	Or       []*ProductCategoriesBoolExp `json:"_or"`
	ID       *UUIDComparisonExp          `json:"id"`
	Name     *StringComparisonExp        `json:"name"`
	Products *ProductsBoolExp            `json:"products"`
}

// input type for inserting data into table "product_categories"
type ProductCategoriesInsertInput struct {
	ID       *string                    `json:"id"`
	Name     *string                    `json:"name"`
	Products *ProductsArrRelInsertInput `json:"products"`
}

// aggregate max on columns
type ProductCategoriesMaxFields struct {
	ID   *string `json:"id"`
	Name *string `json:"name"`
}

// order by max() on columns of table "product_categories"
type ProductCategoriesMaxOrderBy struct {
	ID   *OrderBy `json:"id"`
	Name *OrderBy `json:"name"`
}

// aggregate min on columns
type ProductCategoriesMinFields struct {
	ID   *string `json:"id"`
	Name *string `json:"name"`
}

// order by min() on columns of table "product_categories"
type ProductCategoriesMinOrderBy struct {
	ID   *OrderBy `json:"id"`
	Name *OrderBy `json:"name"`
}

// response of any mutation on the table "product_categories"
type ProductCategoriesMutationResponse struct {
	// number of affected rows by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data of the affected rows by the mutation
	Returning []*ProductCategories `json:"returning"`
}

// input type for inserting object relation for remote table "product_categories"
type ProductCategoriesObjRelInsertInput struct {
	Data       *ProductCategoriesInsertInput `json:"data"`
	OnConflict *ProductCategoriesOnConflict  `json:"on_conflict"`
}

// on conflict condition type for table "product_categories"
type ProductCategoriesOnConflict struct {
	Constraint    ProductCategoriesConstraint     `json:"constraint"`
	UpdateColumns []ProductCategoriesUpdateColumn `json:"update_columns"`
	Where         *ProductCategoriesBoolExp       `json:"where"`
}

// ordering options when selecting data from "product_categories"
type ProductCategoriesOrderBy struct {
	ID                *OrderBy                  `json:"id"`
	Name              *OrderBy                  `json:"name"`
	ProductsAggregate *ProductsAggregateOrderBy `json:"products_aggregate"`
}

// primary key columns input for table: "product_categories"
type ProductCategoriesPkColumnsInput struct {
	ID string `json:"id"`
}

// input type for updating data in table "product_categories"
type ProductCategoriesSetInput struct {
	ID   *string `json:"id"`
	Name *string `json:"name"`
}

// columns and relationships of "product_packagings"
type ProductPackagings struct {
	ID    string `json:"id"`
	Notes string `json:"notes"`
	// An array relationship
	Products []*Products `json:"products"`
	// An aggregated array relationship
	ProductsAggregate *ProductsAggregate `json:"products_aggregate"`
	Unit              string             `json:"unit"`
}

// aggregated selection of "product_packagings"
type ProductPackagingsAggregate struct {
	Aggregate *ProductPackagingsAggregateFields `json:"aggregate"`
	Nodes     []*ProductPackagings              `json:"nodes"`
}

// aggregate fields of "product_packagings"
type ProductPackagingsAggregateFields struct {
	Count *int64                      `json:"count"`
	Max   *ProductPackagingsMaxFields `json:"max"`
	Min   *ProductPackagingsMinFields `json:"min"`
}

// order by aggregate values of table "product_packagings"
type ProductPackagingsAggregateOrderBy struct {
	Count *OrderBy                     `json:"count"`
	Max   *ProductPackagingsMaxOrderBy `json:"max"`
	Min   *ProductPackagingsMinOrderBy `json:"min"`
}

// input type for inserting array relation for remote table "product_packagings"
type ProductPackagingsArrRelInsertInput struct {
	Data       []*ProductPackagingsInsertInput `json:"data"`
	OnConflict *ProductPackagingsOnConflict    `json:"on_conflict"`
}

// Boolean expression to filter rows from the table "product_packagings". All fields are combined with a logical 'AND'.
type ProductPackagingsBoolExp struct {
	And      []*ProductPackagingsBoolExp `json:"_and"`
	Not      *ProductPackagingsBoolExp   `json:"_not"`
	Or       []*ProductPackagingsBoolExp `json:"_or"`
	ID       *UUIDComparisonExp          `json:"id"`
	Notes    *StringComparisonExp        `json:"notes"`
	Products *ProductsBoolExp            `json:"products"`
	Unit     *StringComparisonExp        `json:"unit"`
}

// input type for inserting data into table "product_packagings"
type ProductPackagingsInsertInput struct {
	ID       *string                    `json:"id"`
	Notes    *string                    `json:"notes"`
	Products *ProductsArrRelInsertInput `json:"products"`
	Unit     *string                    `json:"unit"`
}

// aggregate max on columns
type ProductPackagingsMaxFields struct {
	ID    *string `json:"id"`
	Notes *string `json:"notes"`
	Unit  *string `json:"unit"`
}

// order by max() on columns of table "product_packagings"
type ProductPackagingsMaxOrderBy struct {
	ID    *OrderBy `json:"id"`
	Notes *OrderBy `json:"notes"`
	Unit  *OrderBy `json:"unit"`
}

// aggregate min on columns
type ProductPackagingsMinFields struct {
	ID    *string `json:"id"`
	Notes *string `json:"notes"`
	Unit  *string `json:"unit"`
}

// order by min() on columns of table "product_packagings"
type ProductPackagingsMinOrderBy struct {
	ID    *OrderBy `json:"id"`
	Notes *OrderBy `json:"notes"`
	Unit  *OrderBy `json:"unit"`
}

// response of any mutation on the table "product_packagings"
type ProductPackagingsMutationResponse struct {
	// number of affected rows by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data of the affected rows by the mutation
	Returning []*ProductPackagings `json:"returning"`
}

// input type for inserting object relation for remote table "product_packagings"
type ProductPackagingsObjRelInsertInput struct {
	Data       *ProductPackagingsInsertInput `json:"data"`
	OnConflict *ProductPackagingsOnConflict  `json:"on_conflict"`
}

// on conflict condition type for table "product_packagings"
type ProductPackagingsOnConflict struct {
	Constraint    ProductPackagingsConstraint     `json:"constraint"`
	UpdateColumns []ProductPackagingsUpdateColumn `json:"update_columns"`
	Where         *ProductPackagingsBoolExp       `json:"where"`
}

// ordering options when selecting data from "product_packagings"
type ProductPackagingsOrderBy struct {
	ID                *OrderBy                  `json:"id"`
	Notes             *OrderBy                  `json:"notes"`
	ProductsAggregate *ProductsAggregateOrderBy `json:"products_aggregate"`
	Unit              *OrderBy                  `json:"unit"`
}

// primary key columns input for table: "product_packagings"
type ProductPackagingsPkColumnsInput struct {
	ID string `json:"id"`
}

// input type for updating data in table "product_packagings"
type ProductPackagingsSetInput struct {
	ID    *string `json:"id"`
	Notes *string `json:"notes"`
	Unit  *string `json:"unit"`
}

// columns and relationships of "product_pictures"
type ProductPictures struct {
	Expiry  string  `json:"expiry"`
	ID      string  `json:"id"`
	Picture *string `json:"picture"`
	// An object relationship
	Product   *Products `json:"product"`
	ProductID string    `json:"product_id"`
}

// aggregated selection of "product_pictures"
type ProductPicturesAggregate struct {
	Aggregate *ProductPicturesAggregateFields `json:"aggregate"`
	Nodes     []*ProductPictures              `json:"nodes"`
}

// aggregate fields of "product_pictures"
type ProductPicturesAggregateFields struct {
	Count *int64                    `json:"count"`
	Max   *ProductPicturesMaxFields `json:"max"`
	Min   *ProductPicturesMinFields `json:"min"`
}

// order by aggregate values of table "product_pictures"
type ProductPicturesAggregateOrderBy struct {
	Count *OrderBy                   `json:"count"`
	Max   *ProductPicturesMaxOrderBy `json:"max"`
	Min   *ProductPicturesMinOrderBy `json:"min"`
}

// input type for inserting array relation for remote table "product_pictures"
type ProductPicturesArrRelInsertInput struct {
	Data       []*ProductPicturesInsertInput `json:"data"`
	OnConflict *ProductPicturesOnConflict    `json:"on_conflict"`
}

// Boolean expression to filter rows from the table "product_pictures". All fields are combined with a logical 'AND'.
type ProductPicturesBoolExp struct {
	And       []*ProductPicturesBoolExp `json:"_and"`
	Not       *ProductPicturesBoolExp   `json:"_not"`
	Or        []*ProductPicturesBoolExp `json:"_or"`
	Expiry    *IntervalComparisonExp    `json:"expiry"`
	ID        *UUIDComparisonExp        `json:"id"`
	Picture   *StringComparisonExp      `json:"picture"`
	Product   *ProductsBoolExp          `json:"product"`
	ProductID *UUIDComparisonExp        `json:"product_id"`
}

// input type for inserting data into table "product_pictures"
type ProductPicturesInsertInput struct {
	Expiry    *string                    `json:"expiry"`
	ID        *string                    `json:"id"`
	Picture   *string                    `json:"picture"`
	Product   *ProductsObjRelInsertInput `json:"product"`
	ProductID *string                    `json:"product_id"`
}

// aggregate max on columns
type ProductPicturesMaxFields struct {
	ID        *string `json:"id"`
	Picture   *string `json:"picture"`
	ProductID *string `json:"product_id"`
}

// order by max() on columns of table "product_pictures"
type ProductPicturesMaxOrderBy struct {
	ID        *OrderBy `json:"id"`
	Picture   *OrderBy `json:"picture"`
	ProductID *OrderBy `json:"product_id"`
}

// aggregate min on columns
type ProductPicturesMinFields struct {
	ID        *string `json:"id"`
	Picture   *string `json:"picture"`
	ProductID *string `json:"product_id"`
}

// order by min() on columns of table "product_pictures"
type ProductPicturesMinOrderBy struct {
	ID        *OrderBy `json:"id"`
	Picture   *OrderBy `json:"picture"`
	ProductID *OrderBy `json:"product_id"`
}

// response of any mutation on the table "product_pictures"
type ProductPicturesMutationResponse struct {
	// number of affected rows by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data of the affected rows by the mutation
	Returning []*ProductPictures `json:"returning"`
}

// input type for inserting object relation for remote table "product_pictures"
type ProductPicturesObjRelInsertInput struct {
	Data       *ProductPicturesInsertInput `json:"data"`
	OnConflict *ProductPicturesOnConflict  `json:"on_conflict"`
}

// on conflict condition type for table "product_pictures"
type ProductPicturesOnConflict struct {
	Constraint    ProductPicturesConstraint     `json:"constraint"`
	UpdateColumns []ProductPicturesUpdateColumn `json:"update_columns"`
	Where         *ProductPicturesBoolExp       `json:"where"`
}

// ordering options when selecting data from "product_pictures"
type ProductPicturesOrderBy struct {
	Expiry    *OrderBy         `json:"expiry"`
	ID        *OrderBy         `json:"id"`
	Picture   *OrderBy         `json:"picture"`
	Product   *ProductsOrderBy `json:"product"`
	ProductID *OrderBy         `json:"product_id"`
}

// primary key columns input for table: "product_pictures"
type ProductPicturesPkColumnsInput struct {
	ID string `json:"id"`
}

// input type for updating data in table "product_pictures"
type ProductPicturesSetInput struct {
	Expiry    *string `json:"expiry"`
	ID        *string `json:"id"`
	Picture   *string `json:"picture"`
	ProductID *string `json:"product_id"`
}

// expression to compare columns of type product_type. All fields are combined with logical 'AND'.
type ProductTypeComparisonExp struct {
	Eq     *string  `json:"_eq"`
	Gt     *string  `json:"_gt"`
	Gte    *string  `json:"_gte"`
	In     []string `json:"_in"`
	IsNull *bool    `json:"_is_null"`
	Lt     *string  `json:"_lt"`
	Lte    *string  `json:"_lte"`
	Neq    *string  `json:"_neq"`
	Nin    []string `json:"_nin"`
}

// product table
//
//
// columns and relationships of "products"
//
type Products struct {
	CategoryID     *string `json:"category_id"`
	CreatedAt      string  `json:"created_at"`
	ExpiryInterval *string `json:"expiry_interval"`
	ID             string  `json:"id"`
	// An array relationship
	Inventories []*Inventories `json:"inventories"`
	// An aggregated array relationship
	InventoriesAggregate *InventoriesAggregate `json:"inventories_aggregate"`
	IsActive             bool                  `json:"is_active"`
	Name                 string                `json:"name"`
	PackagingID          *string               `json:"packaging_id"`
	// An object relationship
	ProductCategory *ProductCategories `json:"product_category"`
	ProductCode     string             `json:"product_code"`
	// An object relationship
	ProductPackaging *ProductPackagings `json:"product_packaging"`
	// An array relationship
	ProductPictures []*ProductPictures `json:"product_pictures"`
	// An aggregated array relationship
	ProductPicturesAggregate *ProductPicturesAggregate `json:"product_pictures_aggregate"`
	ProductType              string                    `json:"product_type"`
	Srp                      *string                   `json:"srp"`
	Variant                  string                    `json:"variant"`
}

// aggregated selection of "products"
type ProductsAggregate struct {
	Aggregate *ProductsAggregateFields `json:"aggregate"`
	Nodes     []*Products              `json:"nodes"`
}

// aggregate fields of "products"
type ProductsAggregateFields struct {
	Avg        *ProductsAvgFields        `json:"avg"`
	Count      *int64                    `json:"count"`
	Max        *ProductsMaxFields        `json:"max"`
	Min        *ProductsMinFields        `json:"min"`
	Stddev     *ProductsStddevFields     `json:"stddev"`
	StddevPop  *ProductsStddevPopFields  `json:"stddev_pop"`
	StddevSamp *ProductsStddevSampFields `json:"stddev_samp"`
	Sum        *ProductsSumFields        `json:"sum"`
	VarPop     *ProductsVarPopFields     `json:"var_pop"`
	VarSamp    *ProductsVarSampFields    `json:"var_samp"`
	Variance   *ProductsVarianceFields   `json:"variance"`
}

// order by aggregate values of table "products"
type ProductsAggregateOrderBy struct {
	Avg        *ProductsAvgOrderBy        `json:"avg"`
	Count      *OrderBy                   `json:"count"`
	Max        *ProductsMaxOrderBy        `json:"max"`
	Min        *ProductsMinOrderBy        `json:"min"`
	Stddev     *ProductsStddevOrderBy     `json:"stddev"`
	StddevPop  *ProductsStddevPopOrderBy  `json:"stddev_pop"`
	StddevSamp *ProductsStddevSampOrderBy `json:"stddev_samp"`
	Sum        *ProductsSumOrderBy        `json:"sum"`
	VarPop     *ProductsVarPopOrderBy     `json:"var_pop"`
	VarSamp    *ProductsVarSampOrderBy    `json:"var_samp"`
	Variance   *ProductsVarianceOrderBy   `json:"variance"`
}

// input type for inserting array relation for remote table "products"
type ProductsArrRelInsertInput struct {
	Data       []*ProductsInsertInput `json:"data"`
	OnConflict *ProductsOnConflict    `json:"on_conflict"`
}

// aggregate avg on columns
type ProductsAvgFields struct {
	Srp *float64 `json:"srp"`
}

// order by avg() on columns of table "products"
type ProductsAvgOrderBy struct {
	Srp *OrderBy `json:"srp"`
}

// Boolean expression to filter rows from the table "products". All fields are combined with a logical 'AND'.
type ProductsBoolExp struct {
	And              []*ProductsBoolExp        `json:"_and"`
	Not              *ProductsBoolExp          `json:"_not"`
	Or               []*ProductsBoolExp        `json:"_or"`
	CategoryID       *UUIDComparisonExp        `json:"category_id"`
	CreatedAt        *TimestamptzComparisonExp `json:"created_at"`
	ExpiryInterval   *IntervalComparisonExp    `json:"expiry_interval"`
	ID               *UUIDComparisonExp        `json:"id"`
	Inventories      *InventoriesBoolExp       `json:"inventories"`
	IsActive         *BooleanComparisonExp     `json:"is_active"`
	Name             *StringComparisonExp      `json:"name"`
	PackagingID      *UUIDComparisonExp        `json:"packaging_id"`
	ProductCategory  *ProductCategoriesBoolExp `json:"product_category"`
	ProductCode      *StringComparisonExp      `json:"product_code"`
	ProductPackaging *ProductPackagingsBoolExp `json:"product_packaging"`
	ProductPictures  *ProductPicturesBoolExp   `json:"product_pictures"`
	ProductType      *ProductTypeComparisonExp `json:"product_type"`
	Srp              *Float8ComparisonExp      `json:"srp"`
	Variant          *StringComparisonExp      `json:"variant"`
}

// input type for incrementing integer column in table "products"
type ProductsIncInput struct {
	Srp *string `json:"srp"`
}

// input type for inserting data into table "products"
type ProductsInsertInput struct {
	CategoryID       *string                             `json:"category_id"`
	CreatedAt        *string                             `json:"created_at"`
	ExpiryInterval   *string                             `json:"expiry_interval"`
	ID               *string                             `json:"id"`
	Inventories      *InventoriesArrRelInsertInput       `json:"inventories"`
	IsActive         *bool                               `json:"is_active"`
	Name             *string                             `json:"name"`
	PackagingID      *string                             `json:"packaging_id"`
	ProductCategory  *ProductCategoriesObjRelInsertInput `json:"product_category"`
	ProductCode      *string                             `json:"product_code"`
	ProductPackaging *ProductPackagingsObjRelInsertInput `json:"product_packaging"`
	ProductPictures  *ProductPicturesArrRelInsertInput   `json:"product_pictures"`
	ProductType      *string                             `json:"product_type"`
	Srp              *string                             `json:"srp"`
	Variant          *string                             `json:"variant"`
}

// aggregate max on columns
type ProductsMaxFields struct {
	CategoryID  *string `json:"category_id"`
	CreatedAt   *string `json:"created_at"`
	ID          *string `json:"id"`
	Name        *string `json:"name"`
	PackagingID *string `json:"packaging_id"`
	ProductCode *string `json:"product_code"`
	Srp         *string `json:"srp"`
	Variant     *string `json:"variant"`
}

// order by max() on columns of table "products"
type ProductsMaxOrderBy struct {
	CategoryID  *OrderBy `json:"category_id"`
	CreatedAt   *OrderBy `json:"created_at"`
	ID          *OrderBy `json:"id"`
	Name        *OrderBy `json:"name"`
	PackagingID *OrderBy `json:"packaging_id"`
	ProductCode *OrderBy `json:"product_code"`
	Srp         *OrderBy `json:"srp"`
	Variant     *OrderBy `json:"variant"`
}

// aggregate min on columns
type ProductsMinFields struct {
	CategoryID  *string `json:"category_id"`
	CreatedAt   *string `json:"created_at"`
	ID          *string `json:"id"`
	Name        *string `json:"name"`
	PackagingID *string `json:"packaging_id"`
	ProductCode *string `json:"product_code"`
	Srp         *string `json:"srp"`
	Variant     *string `json:"variant"`
}

// order by min() on columns of table "products"
type ProductsMinOrderBy struct {
	CategoryID  *OrderBy `json:"category_id"`
	CreatedAt   *OrderBy `json:"created_at"`
	ID          *OrderBy `json:"id"`
	Name        *OrderBy `json:"name"`
	PackagingID *OrderBy `json:"packaging_id"`
	ProductCode *OrderBy `json:"product_code"`
	Srp         *OrderBy `json:"srp"`
	Variant     *OrderBy `json:"variant"`
}

// response of any mutation on the table "products"
type ProductsMutationResponse struct {
	// number of affected rows by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data of the affected rows by the mutation
	Returning []*Products `json:"returning"`
}

// input type for inserting object relation for remote table "products"
type ProductsObjRelInsertInput struct {
	Data       *ProductsInsertInput `json:"data"`
	OnConflict *ProductsOnConflict  `json:"on_conflict"`
}

// on conflict condition type for table "products"
type ProductsOnConflict struct {
	Constraint    ProductsConstraint     `json:"constraint"`
	UpdateColumns []ProductsUpdateColumn `json:"update_columns"`
	Where         *ProductsBoolExp       `json:"where"`
}

// ordering options when selecting data from "products"
type ProductsOrderBy struct {
	CategoryID               *OrderBy                         `json:"category_id"`
	CreatedAt                *OrderBy                         `json:"created_at"`
	ExpiryInterval           *OrderBy                         `json:"expiry_interval"`
	ID                       *OrderBy                         `json:"id"`
	InventoriesAggregate     *InventoriesAggregateOrderBy     `json:"inventories_aggregate"`
	IsActive                 *OrderBy                         `json:"is_active"`
	Name                     *OrderBy                         `json:"name"`
	PackagingID              *OrderBy                         `json:"packaging_id"`
	ProductCategory          *ProductCategoriesOrderBy        `json:"product_category"`
	ProductCode              *OrderBy                         `json:"product_code"`
	ProductPackaging         *ProductPackagingsOrderBy        `json:"product_packaging"`
	ProductPicturesAggregate *ProductPicturesAggregateOrderBy `json:"product_pictures_aggregate"`
	ProductType              *OrderBy                         `json:"product_type"`
	Srp                      *OrderBy                         `json:"srp"`
	Variant                  *OrderBy                         `json:"variant"`
}

// primary key columns input for table: "products"
type ProductsPkColumnsInput struct {
	ID string `json:"id"`
}

// input type for updating data in table "products"
type ProductsSetInput struct {
	CategoryID     *string `json:"category_id"`
	CreatedAt      *string `json:"created_at"`
	ExpiryInterval *string `json:"expiry_interval"`
	ID             *string `json:"id"`
	IsActive       *bool   `json:"is_active"`
	Name           *string `json:"name"`
	PackagingID    *string `json:"packaging_id"`
	ProductCode    *string `json:"product_code"`
	ProductType    *string `json:"product_type"`
	Srp            *string `json:"srp"`
	Variant        *string `json:"variant"`
}

// aggregate stddev on columns
type ProductsStddevFields struct {
	Srp *float64 `json:"srp"`
}

// order by stddev() on columns of table "products"
type ProductsStddevOrderBy struct {
	Srp *OrderBy `json:"srp"`
}

// aggregate stddev_pop on columns
type ProductsStddevPopFields struct {
	Srp *float64 `json:"srp"`
}

// order by stddev_pop() on columns of table "products"
type ProductsStddevPopOrderBy struct {
	Srp *OrderBy `json:"srp"`
}

// aggregate stddev_samp on columns
type ProductsStddevSampFields struct {
	Srp *float64 `json:"srp"`
}

// order by stddev_samp() on columns of table "products"
type ProductsStddevSampOrderBy struct {
	Srp *OrderBy `json:"srp"`
}

// aggregate sum on columns
type ProductsSumFields struct {
	Srp *string `json:"srp"`
}

// order by sum() on columns of table "products"
type ProductsSumOrderBy struct {
	Srp *OrderBy `json:"srp"`
}

// aggregate var_pop on columns
type ProductsVarPopFields struct {
	Srp *float64 `json:"srp"`
}

// order by var_pop() on columns of table "products"
type ProductsVarPopOrderBy struct {
	Srp *OrderBy `json:"srp"`
}

// aggregate var_samp on columns
type ProductsVarSampFields struct {
	Srp *float64 `json:"srp"`
}

// order by var_samp() on columns of table "products"
type ProductsVarSampOrderBy struct {
	Srp *OrderBy `json:"srp"`
}

// aggregate variance on columns
type ProductsVarianceFields struct {
	Srp *float64 `json:"srp"`
}

// order by variance() on columns of table "products"
type ProductsVarianceOrderBy struct {
	Srp *OrderBy `json:"srp"`
}

type SearchProductCategoriesArgs struct {
	Search *string `json:"search"`
}

type SearchProductsArgs struct {
	Search *string `json:"search"`
}

type StDWithinGeographyInput struct {
	Distance    float64 `json:"distance"`
	From        string  `json:"from"`
	UseSpheroid *bool   `json:"use_spheroid"`
}

type StDWithinInput struct {
	Distance float64 `json:"distance"`
	From     string  `json:"from"`
}

// subscription root
type SubscriptionRoot struct {
	// fetch data from the table: "accounts"
	Accounts []*Accounts `json:"accounts"`
	// fetch aggregated fields from the table: "accounts"
	AccountsAggregate *AccountsAggregate `json:"accounts_aggregate"`
	// fetch data from the table: "accounts" using primary key columns
	AccountsByPk *Accounts `json:"accounts_by_pk"`
	// fetch data from the table: "attendance_config"
	AttendanceConfig []*AttendanceConfig `json:"attendance_config"`
	// fetch aggregated fields from the table: "attendance_config"
	AttendanceConfigAggregate *AttendanceConfigAggregate `json:"attendance_config_aggregate"`
	// fetch data from the table: "attendance_config" using primary key columns
	AttendanceConfigByPk *AttendanceConfig `json:"attendance_config_by_pk"`
	// fetch data from the table: "attendance_records"
	AttendanceRecords []*AttendanceRecords `json:"attendance_records"`
	// fetch aggregated fields from the table: "attendance_records"
	AttendanceRecordsAggregate *AttendanceRecordsAggregate `json:"attendance_records_aggregate"`
	// fetch data from the table: "attendance_records" using primary key columns
	AttendanceRecordsByPk *AttendanceRecords `json:"attendance_records_by_pk"`
	// fetch data from the table: "branches"
	Branches []*Branches `json:"branches"`
	// fetch aggregated fields from the table: "branches"
	BranchesAggregate *BranchesAggregate `json:"branches_aggregate"`
	// fetch data from the table: "branches" using primary key columns
	BranchesByPk *Branches `json:"branches_by_pk"`
	// fetch data from the table: "contracts"
	Contracts []*Contracts `json:"contracts"`
	// fetch aggregated fields from the table: "contracts"
	ContractsAggregate *ContractsAggregate `json:"contracts_aggregate"`
	// fetch data from the table: "contracts" using primary key columns
	ContractsByPk *Contracts `json:"contracts_by_pk"`
	// fetch data from the table: "distributors"
	Distributors []*Distributors `json:"distributors"`
	// fetch aggregated fields from the table: "distributors"
	DistributorsAggregate *DistributorsAggregate `json:"distributors_aggregate"`
	// fetch data from the table: "distributors" using primary key columns
	DistributorsByPk *Distributors `json:"distributors_by_pk"`
	// fetch data from the table: "distro_store_assignments"
	DistroStoreAssignments []*DistroStoreAssignments `json:"distro_store_assignments"`
	// fetch aggregated fields from the table: "distro_store_assignments"
	DistroStoreAssignmentsAggregate *DistroStoreAssignmentsAggregate `json:"distro_store_assignments_aggregate"`
	// fetch data from the table: "distro_store_assignments" using primary key columns
	DistroStoreAssignmentsByPk *DistroStoreAssignments `json:"distro_store_assignments_by_pk"`
	// execute function "get_session_role" which returns "text_result"
	GetSessionRole []*TextResult `json:"get_session_role"`
	// execute function "get_session_role" and query aggregates on result of table type "text_result"
	GetSessionRoleAggregate *TextResultAggregate `json:"get_session_role_aggregate"`
	// fetch data from the table: "inventories"
	Inventories []*Inventories `json:"inventories"`
	// fetch aggregated fields from the table: "inventories"
	InventoriesAggregate *InventoriesAggregate `json:"inventories_aggregate"`
	// fetch data from the table: "inventories" using primary key columns
	InventoriesByPk *Inventories `json:"inventories_by_pk"`
	// fetch data from the table: "locations"
	Locations []*Locations `json:"locations"`
	// fetch aggregated fields from the table: "locations"
	LocationsAggregate *LocationsAggregate `json:"locations_aggregate"`
	// fetch data from the table: "locations" using primary key columns
	LocationsByPk *Locations `json:"locations_by_pk"`
	// fetch data from the table: "marketing_regions"
	MarketingRegions []*MarketingRegions `json:"marketing_regions"`
	// fetch aggregated fields from the table: "marketing_regions"
	MarketingRegionsAggregate *MarketingRegionsAggregate `json:"marketing_regions_aggregate"`
	// fetch data from the table: "marketing_regions" using primary key columns
	MarketingRegionsByPk *MarketingRegions `json:"marketing_regions_by_pk"`
	// fetch data from the table: "mate_stores"
	MateStores []*MateStores `json:"mate_stores"`
	// fetch aggregated fields from the table: "mate_stores"
	MateStoresAggregate *MateStoresAggregate `json:"mate_stores_aggregate"`
	// fetch data from the table: "mate_stores" using primary key columns
	MateStoresByPk *MateStores `json:"mate_stores_by_pk"`
	// fetch data from the table: "product_categories"
	ProductCategories []*ProductCategories `json:"product_categories"`
	// fetch aggregated fields from the table: "product_categories"
	ProductCategoriesAggregate *ProductCategoriesAggregate `json:"product_categories_aggregate"`
	// fetch data from the table: "product_categories" using primary key columns
	ProductCategoriesByPk *ProductCategories `json:"product_categories_by_pk"`
	// fetch data from the table: "product_packagings"
	ProductPackagings []*ProductPackagings `json:"product_packagings"`
	// fetch aggregated fields from the table: "product_packagings"
	ProductPackagingsAggregate *ProductPackagingsAggregate `json:"product_packagings_aggregate"`
	// fetch data from the table: "product_packagings" using primary key columns
	ProductPackagingsByPk *ProductPackagings `json:"product_packagings_by_pk"`
	// fetch data from the table: "product_pictures"
	ProductPictures []*ProductPictures `json:"product_pictures"`
	// fetch aggregated fields from the table: "product_pictures"
	ProductPicturesAggregate *ProductPicturesAggregate `json:"product_pictures_aggregate"`
	// fetch data from the table: "product_pictures" using primary key columns
	ProductPicturesByPk *ProductPictures `json:"product_pictures_by_pk"`
	// fetch data from the table: "products"
	Products []*Products `json:"products"`
	// fetch aggregated fields from the table: "products"
	ProductsAggregate *ProductsAggregate `json:"products_aggregate"`
	// fetch data from the table: "products" using primary key columns
	ProductsByPk *Products `json:"products_by_pk"`
	// execute function "search_product_categories" which returns "product_categories"
	SearchProductCategories []*ProductCategories `json:"search_product_categories"`
	// execute function "search_product_categories" and query aggregates on result of table type "product_categories"
	SearchProductCategoriesAggregate *ProductCategoriesAggregate `json:"search_product_categories_aggregate"`
	// execute function "search_products" which returns "products"
	SearchProducts []*Products `json:"search_products"`
	// execute function "search_products" and query aggregates on result of table type "products"
	SearchProductsAggregate *ProductsAggregate `json:"search_products_aggregate"`
	// fetch data from the table: "text_result"
	TextResult []*TextResult `json:"text_result"`
	// fetch aggregated fields from the table: "text_result"
	TextResultAggregate *TextResultAggregate `json:"text_result_aggregate"`
	// fetch data from the table: "user_pictures"
	UserPictures []*UserPictures `json:"user_pictures"`
	// fetch aggregated fields from the table: "user_pictures"
	UserPicturesAggregate *UserPicturesAggregate `json:"user_pictures_aggregate"`
	// fetch data from the table: "user_pictures" using primary key columns
	UserPicturesByPk *UserPictures `json:"user_pictures_by_pk"`
	// fetch data from the table: "user_profiles"
	UserProfiles []*UserProfiles `json:"user_profiles"`
	// fetch aggregated fields from the table: "user_profiles"
	UserProfilesAggregate *UserProfilesAggregate `json:"user_profiles_aggregate"`
	// fetch data from the table: "user_profiles" using primary key columns
	UserProfilesByPk *UserProfiles `json:"user_profiles_by_pk"`
	// fetch data from the table: "users"
	Users []*Users `json:"users"`
	// fetch aggregated fields from the table: "users"
	UsersAggregate *UsersAggregate `json:"users_aggregate"`
	// fetch data from the table: "users" using primary key columns
	UsersByPk *Users `json:"users_by_pk"`
}

// columns and relationships of "text_result"
type TextResult struct {
	Result *string `json:"result"`
}

// aggregated selection of "text_result"
type TextResultAggregate struct {
	Aggregate *TextResultAggregateFields `json:"aggregate"`
	Nodes     []*TextResult              `json:"nodes"`
}

// aggregate fields of "text_result"
type TextResultAggregateFields struct {
	Count *int64               `json:"count"`
	Max   *TextResultMaxFields `json:"max"`
	Min   *TextResultMinFields `json:"min"`
}

// order by aggregate values of table "text_result"
type TextResultAggregateOrderBy struct {
	Count *OrderBy              `json:"count"`
	Max   *TextResultMaxOrderBy `json:"max"`
	Min   *TextResultMinOrderBy `json:"min"`
}

// input type for inserting array relation for remote table "text_result"
type TextResultArrRelInsertInput struct {
	Data []*TextResultInsertInput `json:"data"`
}

// Boolean expression to filter rows from the table "text_result". All fields are combined with a logical 'AND'.
type TextResultBoolExp struct {
	And    []*TextResultBoolExp `json:"_and"`
	Not    *TextResultBoolExp   `json:"_not"`
	Or     []*TextResultBoolExp `json:"_or"`
	Result *StringComparisonExp `json:"result"`
}

// input type for inserting data into table "text_result"
type TextResultInsertInput struct {
	Result *string `json:"result"`
}

// aggregate max on columns
type TextResultMaxFields struct {
	Result *string `json:"result"`
}

// order by max() on columns of table "text_result"
type TextResultMaxOrderBy struct {
	Result *OrderBy `json:"result"`
}

// aggregate min on columns
type TextResultMinFields struct {
	Result *string `json:"result"`
}

// order by min() on columns of table "text_result"
type TextResultMinOrderBy struct {
	Result *OrderBy `json:"result"`
}

// response of any mutation on the table "text_result"
type TextResultMutationResponse struct {
	// number of affected rows by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data of the affected rows by the mutation
	Returning []*TextResult `json:"returning"`
}

// input type for inserting object relation for remote table "text_result"
type TextResultObjRelInsertInput struct {
	Data *TextResultInsertInput `json:"data"`
}

// ordering options when selecting data from "text_result"
type TextResultOrderBy struct {
	Result *OrderBy `json:"result"`
}

// input type for updating data in table "text_result"
type TextResultSetInput struct {
	Result *string `json:"result"`
}

// expression to compare columns of type timestamp. All fields are combined with logical 'AND'.
type TimestampComparisonExp struct {
	Eq     *string  `json:"_eq"`
	Gt     *string  `json:"_gt"`
	Gte    *string  `json:"_gte"`
	In     []string `json:"_in"`
	IsNull *bool    `json:"_is_null"`
	Lt     *string  `json:"_lt"`
	Lte    *string  `json:"_lte"`
	Neq    *string  `json:"_neq"`
	Nin    []string `json:"_nin"`
}

// expression to compare columns of type timestamptz. All fields are combined with logical 'AND'.
type TimestamptzComparisonExp struct {
	Eq     *string  `json:"_eq"`
	Gt     *string  `json:"_gt"`
	Gte    *string  `json:"_gte"`
	In     []string `json:"_in"`
	IsNull *bool    `json:"_is_null"`
	Lt     *string  `json:"_lt"`
	Lte    *string  `json:"_lte"`
	Neq    *string  `json:"_neq"`
	Nin    []string `json:"_nin"`
}

// columns and relationships of "user_pictures"
type UserPictures struct {
	// An object relationship
	Account    *Accounts `json:"account"`
	AccountID  string    `json:"account_id"`
	ID         string    `json:"id"`
	PictureURL *string   `json:"picture_url"`
}

// aggregated selection of "user_pictures"
type UserPicturesAggregate struct {
	Aggregate *UserPicturesAggregateFields `json:"aggregate"`
	Nodes     []*UserPictures              `json:"nodes"`
}

// aggregate fields of "user_pictures"
type UserPicturesAggregateFields struct {
	Count *int64                 `json:"count"`
	Max   *UserPicturesMaxFields `json:"max"`
	Min   *UserPicturesMinFields `json:"min"`
}

// order by aggregate values of table "user_pictures"
type UserPicturesAggregateOrderBy struct {
	Count *OrderBy                `json:"count"`
	Max   *UserPicturesMaxOrderBy `json:"max"`
	Min   *UserPicturesMinOrderBy `json:"min"`
}

// input type for inserting array relation for remote table "user_pictures"
type UserPicturesArrRelInsertInput struct {
	Data       []*UserPicturesInsertInput `json:"data"`
	OnConflict *UserPicturesOnConflict    `json:"on_conflict"`
}

// Boolean expression to filter rows from the table "user_pictures". All fields are combined with a logical 'AND'.
type UserPicturesBoolExp struct {
	And        []*UserPicturesBoolExp `json:"_and"`
	Not        *UserPicturesBoolExp   `json:"_not"`
	Or         []*UserPicturesBoolExp `json:"_or"`
	Account    *AccountsBoolExp       `json:"account"`
	AccountID  *UUIDComparisonExp     `json:"account_id"`
	ID         *UUIDComparisonExp     `json:"id"`
	PictureURL *StringComparisonExp   `json:"picture_url"`
}

// input type for inserting data into table "user_pictures"
type UserPicturesInsertInput struct {
	Account    *AccountsObjRelInsertInput `json:"account"`
	AccountID  *string                    `json:"account_id"`
	ID         *string                    `json:"id"`
	PictureURL *string                    `json:"picture_url"`
}

// aggregate max on columns
type UserPicturesMaxFields struct {
	AccountID  *string `json:"account_id"`
	ID         *string `json:"id"`
	PictureURL *string `json:"picture_url"`
}

// order by max() on columns of table "user_pictures"
type UserPicturesMaxOrderBy struct {
	AccountID  *OrderBy `json:"account_id"`
	ID         *OrderBy `json:"id"`
	PictureURL *OrderBy `json:"picture_url"`
}

// aggregate min on columns
type UserPicturesMinFields struct {
	AccountID  *string `json:"account_id"`
	ID         *string `json:"id"`
	PictureURL *string `json:"picture_url"`
}

// order by min() on columns of table "user_pictures"
type UserPicturesMinOrderBy struct {
	AccountID  *OrderBy `json:"account_id"`
	ID         *OrderBy `json:"id"`
	PictureURL *OrderBy `json:"picture_url"`
}

// response of any mutation on the table "user_pictures"
type UserPicturesMutationResponse struct {
	// number of affected rows by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data of the affected rows by the mutation
	Returning []*UserPictures `json:"returning"`
}

// input type for inserting object relation for remote table "user_pictures"
type UserPicturesObjRelInsertInput struct {
	Data       *UserPicturesInsertInput `json:"data"`
	OnConflict *UserPicturesOnConflict  `json:"on_conflict"`
}

// on conflict condition type for table "user_pictures"
type UserPicturesOnConflict struct {
	Constraint    UserPicturesConstraint     `json:"constraint"`
	UpdateColumns []UserPicturesUpdateColumn `json:"update_columns"`
	Where         *UserPicturesBoolExp       `json:"where"`
}

// ordering options when selecting data from "user_pictures"
type UserPicturesOrderBy struct {
	Account    *AccountsOrderBy `json:"account"`
	AccountID  *OrderBy         `json:"account_id"`
	ID         *OrderBy         `json:"id"`
	PictureURL *OrderBy         `json:"picture_url"`
}

// primary key columns input for table: "user_pictures"
type UserPicturesPkColumnsInput struct {
	ID string `json:"id"`
}

// input type for updating data in table "user_pictures"
type UserPicturesSetInput struct {
	AccountID  *string `json:"account_id"`
	ID         *string `json:"id"`
	PictureURL *string `json:"picture_url"`
}

// columns and relationships of "user_profiles"
type UserProfiles struct {
	Devices *string `json:"devices"`
	ID      string  `json:"id"`
	// An object relationship
	User *Users `json:"user"`
	// An object relationship
	UserByID *Users `json:"userById"`
	UserID   string `json:"user_id"`
}

// aggregated selection of "user_profiles"
type UserProfilesAggregate struct {
	Aggregate *UserProfilesAggregateFields `json:"aggregate"`
	Nodes     []*UserProfiles              `json:"nodes"`
}

// aggregate fields of "user_profiles"
type UserProfilesAggregateFields struct {
	Count *int64                 `json:"count"`
	Max   *UserProfilesMaxFields `json:"max"`
	Min   *UserProfilesMinFields `json:"min"`
}

// order by aggregate values of table "user_profiles"
type UserProfilesAggregateOrderBy struct {
	Count *OrderBy                `json:"count"`
	Max   *UserProfilesMaxOrderBy `json:"max"`
	Min   *UserProfilesMinOrderBy `json:"min"`
}

// append existing jsonb value of filtered columns with new jsonb value
type UserProfilesAppendInput struct {
	Devices *string `json:"devices"`
}

// input type for inserting array relation for remote table "user_profiles"
type UserProfilesArrRelInsertInput struct {
	Data       []*UserProfilesInsertInput `json:"data"`
	OnConflict *UserProfilesOnConflict    `json:"on_conflict"`
}

// Boolean expression to filter rows from the table "user_profiles". All fields are combined with a logical 'AND'.
type UserProfilesBoolExp struct {
	And      []*UserProfilesBoolExp `json:"_and"`
	Not      *UserProfilesBoolExp   `json:"_not"`
	Or       []*UserProfilesBoolExp `json:"_or"`
	Devices  *JsonbComparisonExp    `json:"devices"`
	ID       *UUIDComparisonExp     `json:"id"`
	User     *UsersBoolExp          `json:"user"`
	UserByID *UsersBoolExp          `json:"userById"`
	UserID   *UUIDComparisonExp     `json:"user_id"`
}

// delete the field or element with specified path (for JSON arrays, negative integers count from the end)
type UserProfilesDeleteAtPathInput struct {
	Devices []*string `json:"devices"`
}

// delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
type UserProfilesDeleteElemInput struct {
	Devices *int64 `json:"devices"`
}

// delete key/value pair or string element. key/value pairs are matched based on their key value
type UserProfilesDeleteKeyInput struct {
	Devices *string `json:"devices"`
}

// input type for inserting data into table "user_profiles"
type UserProfilesInsertInput struct {
	Devices  *string                 `json:"devices"`
	ID       *string                 `json:"id"`
	User     *UsersObjRelInsertInput `json:"user"`
	UserByID *UsersObjRelInsertInput `json:"userById"`
	UserID   *string                 `json:"user_id"`
}

// aggregate max on columns
type UserProfilesMaxFields struct {
	ID     *string `json:"id"`
	UserID *string `json:"user_id"`
}

// order by max() on columns of table "user_profiles"
type UserProfilesMaxOrderBy struct {
	ID     *OrderBy `json:"id"`
	UserID *OrderBy `json:"user_id"`
}

// aggregate min on columns
type UserProfilesMinFields struct {
	ID     *string `json:"id"`
	UserID *string `json:"user_id"`
}

// order by min() on columns of table "user_profiles"
type UserProfilesMinOrderBy struct {
	ID     *OrderBy `json:"id"`
	UserID *OrderBy `json:"user_id"`
}

// response of any mutation on the table "user_profiles"
type UserProfilesMutationResponse struct {
	// number of affected rows by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data of the affected rows by the mutation
	Returning []*UserProfiles `json:"returning"`
}

// input type for inserting object relation for remote table "user_profiles"
type UserProfilesObjRelInsertInput struct {
	Data       *UserProfilesInsertInput `json:"data"`
	OnConflict *UserProfilesOnConflict  `json:"on_conflict"`
}

// on conflict condition type for table "user_profiles"
type UserProfilesOnConflict struct {
	Constraint    UserProfilesConstraint     `json:"constraint"`
	UpdateColumns []UserProfilesUpdateColumn `json:"update_columns"`
	Where         *UserProfilesBoolExp       `json:"where"`
}

// ordering options when selecting data from "user_profiles"
type UserProfilesOrderBy struct {
	Devices  *OrderBy      `json:"devices"`
	ID       *OrderBy      `json:"id"`
	User     *UsersOrderBy `json:"user"`
	UserByID *UsersOrderBy `json:"userById"`
	UserID   *OrderBy      `json:"user_id"`
}

// primary key columns input for table: "user_profiles"
type UserProfilesPkColumnsInput struct {
	ID string `json:"id"`
}

// prepend existing jsonb value of filtered columns with new jsonb value
type UserProfilesPrependInput struct {
	Devices *string `json:"devices"`
}

// input type for updating data in table "user_profiles"
type UserProfilesSetInput struct {
	Devices *string `json:"devices"`
	ID      *string `json:"id"`
	UserID  *string `json:"user_id"`
}

// columns and relationships of "users"
type Users struct {
	// An object relationship
	Account    *Accounts `json:"account"`
	AccountID  string    `json:"account_id"`
	Address    string    `json:"address"`
	BirthDate  string    `json:"birth_date"`
	ContractID *string   `json:"contract_id"`
	// An array relationship
	Contracts []*Contracts `json:"contracts"`
	// An aggregated array relationship
	ContractsAggregate *ContractsAggregate `json:"contracts_aggregate"`
	CreatedAt          *string             `json:"created_at"`
	// An array relationship
	DistroStoreAssignments []*DistroStoreAssignments `json:"distro_store_assignments"`
	// An aggregated array relationship
	DistroStoreAssignmentsAggregate *DistroStoreAssignmentsAggregate `json:"distro_store_assignments_aggregate"`
	GovernmentID                    string                           `json:"government_id"`
	ID                              string                           `json:"id"`
	LastModified                    *string                          `json:"last_modified"`
	Locked                          *bool                            `json:"locked"`
	// An object relationship
	MarketingRegion   *MarketingRegions `json:"marketing_region"`
	MarketingRegionID *string           `json:"marketing_region_id"`
	Name              string            `json:"name"`
	ProfileID         *string           `json:"profile_id"`
	// An object relationship
	UserProfileByProfileID *UserProfiles `json:"userProfileByProfileId"`
	// An object relationship
	UserProfile *UserProfiles `json:"user_profile"`
}

// aggregated selection of "users"
type UsersAggregate struct {
	Aggregate *UsersAggregateFields `json:"aggregate"`
	Nodes     []*Users              `json:"nodes"`
}

// aggregate fields of "users"
type UsersAggregateFields struct {
	Count *int64          `json:"count"`
	Max   *UsersMaxFields `json:"max"`
	Min   *UsersMinFields `json:"min"`
}

// order by aggregate values of table "users"
type UsersAggregateOrderBy struct {
	Count *OrderBy         `json:"count"`
	Max   *UsersMaxOrderBy `json:"max"`
	Min   *UsersMinOrderBy `json:"min"`
}

// input type for inserting array relation for remote table "users"
type UsersArrRelInsertInput struct {
	Data       []*UsersInsertInput `json:"data"`
	OnConflict *UsersOnConflict    `json:"on_conflict"`
}

// Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'.
type UsersBoolExp struct {
	And                    []*UsersBoolExp                `json:"_and"`
	Not                    *UsersBoolExp                  `json:"_not"`
	Or                     []*UsersBoolExp                `json:"_or"`
	Account                *AccountsBoolExp               `json:"account"`
	AccountID              *UUIDComparisonExp             `json:"account_id"`
	Address                *StringComparisonExp           `json:"address"`
	BirthDate              *DateComparisonExp             `json:"birth_date"`
	ContractID             *UUIDComparisonExp             `json:"contract_id"`
	Contracts              *ContractsBoolExp              `json:"contracts"`
	CreatedAt              *TimestamptzComparisonExp      `json:"created_at"`
	DistroStoreAssignments *DistroStoreAssignmentsBoolExp `json:"distro_store_assignments"`
	GovernmentID           *StringComparisonExp           `json:"government_id"`
	ID                     *UUIDComparisonExp             `json:"id"`
	LastModified           *TimestamptzComparisonExp      `json:"last_modified"`
	Locked                 *BooleanComparisonExp          `json:"locked"`
	MarketingRegion        *MarketingRegionsBoolExp       `json:"marketing_region"`
	MarketingRegionID      *UUIDComparisonExp             `json:"marketing_region_id"`
	Name                   *StringComparisonExp           `json:"name"`
	ProfileID              *UUIDComparisonExp             `json:"profile_id"`
	UserProfileByProfileID *UserProfilesBoolExp           `json:"userProfileByProfileId"`
	UserProfile            *UserProfilesBoolExp           `json:"user_profile"`
}

// input type for inserting data into table "users"
type UsersInsertInput struct {
	Account                *AccountsObjRelInsertInput               `json:"account"`
	AccountID              *string                                  `json:"account_id"`
	Address                *string                                  `json:"address"`
	BirthDate              *string                                  `json:"birth_date"`
	ContractID             *string                                  `json:"contract_id"`
	Contracts              *ContractsArrRelInsertInput              `json:"contracts"`
	CreatedAt              *string                                  `json:"created_at"`
	DistroStoreAssignments *DistroStoreAssignmentsArrRelInsertInput `json:"distro_store_assignments"`
	GovernmentID           *string                                  `json:"government_id"`
	ID                     *string                                  `json:"id"`
	LastModified           *string                                  `json:"last_modified"`
	Locked                 *bool                                    `json:"locked"`
	MarketingRegion        *MarketingRegionsObjRelInsertInput       `json:"marketing_region"`
	MarketingRegionID      *string                                  `json:"marketing_region_id"`
	Name                   *string                                  `json:"name"`
	ProfileID              *string                                  `json:"profile_id"`
	UserProfileByProfileID *UserProfilesObjRelInsertInput           `json:"userProfileByProfileId"`
	UserProfile            *UserProfilesObjRelInsertInput           `json:"user_profile"`
}

// aggregate max on columns
type UsersMaxFields struct {
	AccountID         *string `json:"account_id"`
	Address           *string `json:"address"`
	BirthDate         *string `json:"birth_date"`
	ContractID        *string `json:"contract_id"`
	CreatedAt         *string `json:"created_at"`
	GovernmentID      *string `json:"government_id"`
	ID                *string `json:"id"`
	LastModified      *string `json:"last_modified"`
	MarketingRegionID *string `json:"marketing_region_id"`
	Name              *string `json:"name"`
	ProfileID         *string `json:"profile_id"`
}

// order by max() on columns of table "users"
type UsersMaxOrderBy struct {
	AccountID         *OrderBy `json:"account_id"`
	Address           *OrderBy `json:"address"`
	BirthDate         *OrderBy `json:"birth_date"`
	ContractID        *OrderBy `json:"contract_id"`
	CreatedAt         *OrderBy `json:"created_at"`
	GovernmentID      *OrderBy `json:"government_id"`
	ID                *OrderBy `json:"id"`
	LastModified      *OrderBy `json:"last_modified"`
	MarketingRegionID *OrderBy `json:"marketing_region_id"`
	Name              *OrderBy `json:"name"`
	ProfileID         *OrderBy `json:"profile_id"`
}

// aggregate min on columns
type UsersMinFields struct {
	AccountID         *string `json:"account_id"`
	Address           *string `json:"address"`
	BirthDate         *string `json:"birth_date"`
	ContractID        *string `json:"contract_id"`
	CreatedAt         *string `json:"created_at"`
	GovernmentID      *string `json:"government_id"`
	ID                *string `json:"id"`
	LastModified      *string `json:"last_modified"`
	MarketingRegionID *string `json:"marketing_region_id"`
	Name              *string `json:"name"`
	ProfileID         *string `json:"profile_id"`
}

// order by min() on columns of table "users"
type UsersMinOrderBy struct {
	AccountID         *OrderBy `json:"account_id"`
	Address           *OrderBy `json:"address"`
	BirthDate         *OrderBy `json:"birth_date"`
	ContractID        *OrderBy `json:"contract_id"`
	CreatedAt         *OrderBy `json:"created_at"`
	GovernmentID      *OrderBy `json:"government_id"`
	ID                *OrderBy `json:"id"`
	LastModified      *OrderBy `json:"last_modified"`
	MarketingRegionID *OrderBy `json:"marketing_region_id"`
	Name              *OrderBy `json:"name"`
	ProfileID         *OrderBy `json:"profile_id"`
}

// response of any mutation on the table "users"
type UsersMutationResponse struct {
	// number of affected rows by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data of the affected rows by the mutation
	Returning []*Users `json:"returning"`
}

// input type for inserting object relation for remote table "users"
type UsersObjRelInsertInput struct {
	Data       *UsersInsertInput `json:"data"`
	OnConflict *UsersOnConflict  `json:"on_conflict"`
}

// on conflict condition type for table "users"
type UsersOnConflict struct {
	Constraint    UsersConstraint     `json:"constraint"`
	UpdateColumns []UsersUpdateColumn `json:"update_columns"`
	Where         *UsersBoolExp       `json:"where"`
}

// ordering options when selecting data from "users"
type UsersOrderBy struct {
	Account                         *AccountsOrderBy                        `json:"account"`
	AccountID                       *OrderBy                                `json:"account_id"`
	Address                         *OrderBy                                `json:"address"`
	BirthDate                       *OrderBy                                `json:"birth_date"`
	ContractID                      *OrderBy                                `json:"contract_id"`
	ContractsAggregate              *ContractsAggregateOrderBy              `json:"contracts_aggregate"`
	CreatedAt                       *OrderBy                                `json:"created_at"`
	DistroStoreAssignmentsAggregate *DistroStoreAssignmentsAggregateOrderBy `json:"distro_store_assignments_aggregate"`
	GovernmentID                    *OrderBy                                `json:"government_id"`
	ID                              *OrderBy                                `json:"id"`
	LastModified                    *OrderBy                                `json:"last_modified"`
	Locked                          *OrderBy                                `json:"locked"`
	MarketingRegion                 *MarketingRegionsOrderBy                `json:"marketing_region"`
	MarketingRegionID               *OrderBy                                `json:"marketing_region_id"`
	Name                            *OrderBy                                `json:"name"`
	ProfileID                       *OrderBy                                `json:"profile_id"`
	UserProfileByProfileID          *UserProfilesOrderBy                    `json:"userProfileByProfileId"`
	UserProfile                     *UserProfilesOrderBy                    `json:"user_profile"`
}

// primary key columns input for table: "users"
type UsersPkColumnsInput struct {
	ID string `json:"id"`
}

// input type for updating data in table "users"
type UsersSetInput struct {
	AccountID         *string `json:"account_id"`
	Address           *string `json:"address"`
	BirthDate         *string `json:"birth_date"`
	ContractID        *string `json:"contract_id"`
	CreatedAt         *string `json:"created_at"`
	GovernmentID      *string `json:"government_id"`
	ID                *string `json:"id"`
	LastModified      *string `json:"last_modified"`
	Locked            *bool   `json:"locked"`
	MarketingRegionID *string `json:"marketing_region_id"`
	Name              *string `json:"name"`
	ProfileID         *string `json:"profile_id"`
}

// expression to compare columns of type uuid. All fields are combined with logical 'AND'.
type UUIDComparisonExp struct {
	Eq     *string  `json:"_eq"`
	Gt     *string  `json:"_gt"`
	Gte    *string  `json:"_gte"`
	In     []string `json:"_in"`
	IsNull *bool    `json:"_is_null"`
	Lt     *string  `json:"_lt"`
	Lte    *string  `json:"_lte"`
	Neq    *string  `json:"_neq"`
	Nin    []string `json:"_nin"`
}

// unique or primary key constraints on table "accounts"
type AccountsConstraint string

const (
	// unique or primary key constraint
	AccountsConstraintAccountsEmailKey AccountsConstraint = "accounts_email_key"
	// unique or primary key constraint
	AccountsConstraintAccountsPkey AccountsConstraint = "accounts_pkey"
)

var AllAccountsConstraint = []AccountsConstraint{
	AccountsConstraintAccountsEmailKey,
	AccountsConstraintAccountsPkey,
}

func (e AccountsConstraint) IsValid() bool {
	switch e {
	case AccountsConstraintAccountsEmailKey, AccountsConstraintAccountsPkey:
		return true
	}
	return false
}

func (e AccountsConstraint) String() string {
	return string(e)
}

func (e *AccountsConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccountsConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid accounts_constraint", str)
	}
	return nil
}

func (e AccountsConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "accounts"
type AccountsSelectColumn string

const (
	// column name
	AccountsSelectColumnEmail AccountsSelectColumn = "email"
	// column name
	AccountsSelectColumnLastLogin AccountsSelectColumn = "last_login"
	// column name
	AccountsSelectColumnRole AccountsSelectColumn = "role"
	// column name
	AccountsSelectColumnUserID AccountsSelectColumn = "user_id"
)

var AllAccountsSelectColumn = []AccountsSelectColumn{
	AccountsSelectColumnEmail,
	AccountsSelectColumnLastLogin,
	AccountsSelectColumnRole,
	AccountsSelectColumnUserID,
}

func (e AccountsSelectColumn) IsValid() bool {
	switch e {
	case AccountsSelectColumnEmail, AccountsSelectColumnLastLogin, AccountsSelectColumnRole, AccountsSelectColumnUserID:
		return true
	}
	return false
}

func (e AccountsSelectColumn) String() string {
	return string(e)
}

func (e *AccountsSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccountsSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid accounts_select_column", str)
	}
	return nil
}

func (e AccountsSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "accounts"
type AccountsUpdateColumn string

const (
	// column name
	AccountsUpdateColumnEmail AccountsUpdateColumn = "email"
	// column name
	AccountsUpdateColumnLastLogin AccountsUpdateColumn = "last_login"
	// column name
	AccountsUpdateColumnRole AccountsUpdateColumn = "role"
	// column name
	AccountsUpdateColumnUserID AccountsUpdateColumn = "user_id"
)

var AllAccountsUpdateColumn = []AccountsUpdateColumn{
	AccountsUpdateColumnEmail,
	AccountsUpdateColumnLastLogin,
	AccountsUpdateColumnRole,
	AccountsUpdateColumnUserID,
}

func (e AccountsUpdateColumn) IsValid() bool {
	switch e {
	case AccountsUpdateColumnEmail, AccountsUpdateColumnLastLogin, AccountsUpdateColumnRole, AccountsUpdateColumnUserID:
		return true
	}
	return false
}

func (e AccountsUpdateColumn) String() string {
	return string(e)
}

func (e *AccountsUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccountsUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid accounts_update_column", str)
	}
	return nil
}

func (e AccountsUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "attendance_config"
type AttendanceConfigConstraint string

const (
	// unique or primary key constraint
	AttendanceConfigConstraintAttendanceConfigPkey AttendanceConfigConstraint = "attendance_config_pkey"
)

var AllAttendanceConfigConstraint = []AttendanceConfigConstraint{
	AttendanceConfigConstraintAttendanceConfigPkey,
}

func (e AttendanceConfigConstraint) IsValid() bool {
	switch e {
	case AttendanceConfigConstraintAttendanceConfigPkey:
		return true
	}
	return false
}

func (e AttendanceConfigConstraint) String() string {
	return string(e)
}

func (e *AttendanceConfigConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AttendanceConfigConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid attendance_config_constraint", str)
	}
	return nil
}

func (e AttendanceConfigConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "attendance_config"
type AttendanceConfigSelectColumn string

const (
	// column name
	AttendanceConfigSelectColumnFullWorkHours AttendanceConfigSelectColumn = "full_work_hours"
	// column name
	AttendanceConfigSelectColumnHalfWorkHours AttendanceConfigSelectColumn = "half_work_hours"
	// column name
	AttendanceConfigSelectColumnID AttendanceConfigSelectColumn = "id"
)

var AllAttendanceConfigSelectColumn = []AttendanceConfigSelectColumn{
	AttendanceConfigSelectColumnFullWorkHours,
	AttendanceConfigSelectColumnHalfWorkHours,
	AttendanceConfigSelectColumnID,
}

func (e AttendanceConfigSelectColumn) IsValid() bool {
	switch e {
	case AttendanceConfigSelectColumnFullWorkHours, AttendanceConfigSelectColumnHalfWorkHours, AttendanceConfigSelectColumnID:
		return true
	}
	return false
}

func (e AttendanceConfigSelectColumn) String() string {
	return string(e)
}

func (e *AttendanceConfigSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AttendanceConfigSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid attendance_config_select_column", str)
	}
	return nil
}

func (e AttendanceConfigSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "attendance_config"
type AttendanceConfigUpdateColumn string

const (
	// column name
	AttendanceConfigUpdateColumnFullWorkHours AttendanceConfigUpdateColumn = "full_work_hours"
	// column name
	AttendanceConfigUpdateColumnHalfWorkHours AttendanceConfigUpdateColumn = "half_work_hours"
	// column name
	AttendanceConfigUpdateColumnID AttendanceConfigUpdateColumn = "id"
)

var AllAttendanceConfigUpdateColumn = []AttendanceConfigUpdateColumn{
	AttendanceConfigUpdateColumnFullWorkHours,
	AttendanceConfigUpdateColumnHalfWorkHours,
	AttendanceConfigUpdateColumnID,
}

func (e AttendanceConfigUpdateColumn) IsValid() bool {
	switch e {
	case AttendanceConfigUpdateColumnFullWorkHours, AttendanceConfigUpdateColumnHalfWorkHours, AttendanceConfigUpdateColumnID:
		return true
	}
	return false
}

func (e AttendanceConfigUpdateColumn) String() string {
	return string(e)
}

func (e *AttendanceConfigUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AttendanceConfigUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid attendance_config_update_column", str)
	}
	return nil
}

func (e AttendanceConfigUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "attendance_records"
type AttendanceRecordsConstraint string

const (
	// unique or primary key constraint
	AttendanceRecordsConstraintAttendanceRecordsPkey AttendanceRecordsConstraint = "attendance_records_pkey"
)

var AllAttendanceRecordsConstraint = []AttendanceRecordsConstraint{
	AttendanceRecordsConstraintAttendanceRecordsPkey,
}

func (e AttendanceRecordsConstraint) IsValid() bool {
	switch e {
	case AttendanceRecordsConstraintAttendanceRecordsPkey:
		return true
	}
	return false
}

func (e AttendanceRecordsConstraint) String() string {
	return string(e)
}

func (e *AttendanceRecordsConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AttendanceRecordsConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid attendance_records_constraint", str)
	}
	return nil
}

func (e AttendanceRecordsConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "attendance_records"
type AttendanceRecordsSelectColumn string

const (
	// column name
	AttendanceRecordsSelectColumnAccountID AttendanceRecordsSelectColumn = "account_id"
	// column name
	AttendanceRecordsSelectColumnCreated AttendanceRecordsSelectColumn = "created"
	// column name
	AttendanceRecordsSelectColumnID AttendanceRecordsSelectColumn = "id"
	// column name
	AttendanceRecordsSelectColumnOnGoingHome AttendanceRecordsSelectColumn = "on_going_home"
	// column name
	AttendanceRecordsSelectColumnOnGoingHomeLoc AttendanceRecordsSelectColumn = "on_going_home_loc"
	// column name
	AttendanceRecordsSelectColumnOnGoingHomeTimestamp AttendanceRecordsSelectColumn = "on_going_home_timestamp"
	// column name
	AttendanceRecordsSelectColumnOnGoingWork AttendanceRecordsSelectColumn = "on_going_work"
	// column name
	AttendanceRecordsSelectColumnOnGoingWorkLoc AttendanceRecordsSelectColumn = "on_going_work_loc"
	// column name
	AttendanceRecordsSelectColumnOnGoingWorkTimestamp AttendanceRecordsSelectColumn = "on_going_work_timestamp"
	// column name
	AttendanceRecordsSelectColumnUpdated AttendanceRecordsSelectColumn = "updated"
)

var AllAttendanceRecordsSelectColumn = []AttendanceRecordsSelectColumn{
	AttendanceRecordsSelectColumnAccountID,
	AttendanceRecordsSelectColumnCreated,
	AttendanceRecordsSelectColumnID,
	AttendanceRecordsSelectColumnOnGoingHome,
	AttendanceRecordsSelectColumnOnGoingHomeLoc,
	AttendanceRecordsSelectColumnOnGoingHomeTimestamp,
	AttendanceRecordsSelectColumnOnGoingWork,
	AttendanceRecordsSelectColumnOnGoingWorkLoc,
	AttendanceRecordsSelectColumnOnGoingWorkTimestamp,
	AttendanceRecordsSelectColumnUpdated,
}

func (e AttendanceRecordsSelectColumn) IsValid() bool {
	switch e {
	case AttendanceRecordsSelectColumnAccountID, AttendanceRecordsSelectColumnCreated, AttendanceRecordsSelectColumnID, AttendanceRecordsSelectColumnOnGoingHome, AttendanceRecordsSelectColumnOnGoingHomeLoc, AttendanceRecordsSelectColumnOnGoingHomeTimestamp, AttendanceRecordsSelectColumnOnGoingWork, AttendanceRecordsSelectColumnOnGoingWorkLoc, AttendanceRecordsSelectColumnOnGoingWorkTimestamp, AttendanceRecordsSelectColumnUpdated:
		return true
	}
	return false
}

func (e AttendanceRecordsSelectColumn) String() string {
	return string(e)
}

func (e *AttendanceRecordsSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AttendanceRecordsSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid attendance_records_select_column", str)
	}
	return nil
}

func (e AttendanceRecordsSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "attendance_records"
type AttendanceRecordsUpdateColumn string

const (
	// column name
	AttendanceRecordsUpdateColumnAccountID AttendanceRecordsUpdateColumn = "account_id"
	// column name
	AttendanceRecordsUpdateColumnCreated AttendanceRecordsUpdateColumn = "created"
	// column name
	AttendanceRecordsUpdateColumnID AttendanceRecordsUpdateColumn = "id"
	// column name
	AttendanceRecordsUpdateColumnOnGoingHome AttendanceRecordsUpdateColumn = "on_going_home"
	// column name
	AttendanceRecordsUpdateColumnOnGoingHomeLoc AttendanceRecordsUpdateColumn = "on_going_home_loc"
	// column name
	AttendanceRecordsUpdateColumnOnGoingHomeTimestamp AttendanceRecordsUpdateColumn = "on_going_home_timestamp"
	// column name
	AttendanceRecordsUpdateColumnOnGoingWork AttendanceRecordsUpdateColumn = "on_going_work"
	// column name
	AttendanceRecordsUpdateColumnOnGoingWorkLoc AttendanceRecordsUpdateColumn = "on_going_work_loc"
	// column name
	AttendanceRecordsUpdateColumnOnGoingWorkTimestamp AttendanceRecordsUpdateColumn = "on_going_work_timestamp"
	// column name
	AttendanceRecordsUpdateColumnUpdated AttendanceRecordsUpdateColumn = "updated"
)

var AllAttendanceRecordsUpdateColumn = []AttendanceRecordsUpdateColumn{
	AttendanceRecordsUpdateColumnAccountID,
	AttendanceRecordsUpdateColumnCreated,
	AttendanceRecordsUpdateColumnID,
	AttendanceRecordsUpdateColumnOnGoingHome,
	AttendanceRecordsUpdateColumnOnGoingHomeLoc,
	AttendanceRecordsUpdateColumnOnGoingHomeTimestamp,
	AttendanceRecordsUpdateColumnOnGoingWork,
	AttendanceRecordsUpdateColumnOnGoingWorkLoc,
	AttendanceRecordsUpdateColumnOnGoingWorkTimestamp,
	AttendanceRecordsUpdateColumnUpdated,
}

func (e AttendanceRecordsUpdateColumn) IsValid() bool {
	switch e {
	case AttendanceRecordsUpdateColumnAccountID, AttendanceRecordsUpdateColumnCreated, AttendanceRecordsUpdateColumnID, AttendanceRecordsUpdateColumnOnGoingHome, AttendanceRecordsUpdateColumnOnGoingHomeLoc, AttendanceRecordsUpdateColumnOnGoingHomeTimestamp, AttendanceRecordsUpdateColumnOnGoingWork, AttendanceRecordsUpdateColumnOnGoingWorkLoc, AttendanceRecordsUpdateColumnOnGoingWorkTimestamp, AttendanceRecordsUpdateColumnUpdated:
		return true
	}
	return false
}

func (e AttendanceRecordsUpdateColumn) String() string {
	return string(e)
}

func (e *AttendanceRecordsUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AttendanceRecordsUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid attendance_records_update_column", str)
	}
	return nil
}

func (e AttendanceRecordsUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "branches"
type BranchesConstraint string

const (
	// unique or primary key constraint
	BranchesConstraintBranchesNameKey BranchesConstraint = "branches_name_key"
	// unique or primary key constraint
	BranchesConstraintBranchesPkey BranchesConstraint = "branches_pkey"
)

var AllBranchesConstraint = []BranchesConstraint{
	BranchesConstraintBranchesNameKey,
	BranchesConstraintBranchesPkey,
}

func (e BranchesConstraint) IsValid() bool {
	switch e {
	case BranchesConstraintBranchesNameKey, BranchesConstraintBranchesPkey:
		return true
	}
	return false
}

func (e BranchesConstraint) String() string {
	return string(e)
}

func (e *BranchesConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BranchesConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid branches_constraint", str)
	}
	return nil
}

func (e BranchesConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "branches"
type BranchesSelectColumn string

const (
	// column name
	BranchesSelectColumnAddress BranchesSelectColumn = "address"
	// column name
	BranchesSelectColumnAreaID BranchesSelectColumn = "area_id"
	// column name
	BranchesSelectColumnCity BranchesSelectColumn = "city"
	// column name
	BranchesSelectColumnCreatedDate BranchesSelectColumn = "created_date"
	// column name
	BranchesSelectColumnDistributorID BranchesSelectColumn = "distributor_id"
	// column name
	BranchesSelectColumnID BranchesSelectColumn = "id"
	// column name
	BranchesSelectColumnLocationID BranchesSelectColumn = "location_id"
	// column name
	BranchesSelectColumnName BranchesSelectColumn = "name"
	// column name
	BranchesSelectColumnProvince BranchesSelectColumn = "province"
	// column name
	BranchesSelectColumnUpdatedDate BranchesSelectColumn = "updated_date"
)

var AllBranchesSelectColumn = []BranchesSelectColumn{
	BranchesSelectColumnAddress,
	BranchesSelectColumnAreaID,
	BranchesSelectColumnCity,
	BranchesSelectColumnCreatedDate,
	BranchesSelectColumnDistributorID,
	BranchesSelectColumnID,
	BranchesSelectColumnLocationID,
	BranchesSelectColumnName,
	BranchesSelectColumnProvince,
	BranchesSelectColumnUpdatedDate,
}

func (e BranchesSelectColumn) IsValid() bool {
	switch e {
	case BranchesSelectColumnAddress, BranchesSelectColumnAreaID, BranchesSelectColumnCity, BranchesSelectColumnCreatedDate, BranchesSelectColumnDistributorID, BranchesSelectColumnID, BranchesSelectColumnLocationID, BranchesSelectColumnName, BranchesSelectColumnProvince, BranchesSelectColumnUpdatedDate:
		return true
	}
	return false
}

func (e BranchesSelectColumn) String() string {
	return string(e)
}

func (e *BranchesSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BranchesSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid branches_select_column", str)
	}
	return nil
}

func (e BranchesSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "branches"
type BranchesUpdateColumn string

const (
	// column name
	BranchesUpdateColumnAddress BranchesUpdateColumn = "address"
	// column name
	BranchesUpdateColumnAreaID BranchesUpdateColumn = "area_id"
	// column name
	BranchesUpdateColumnCity BranchesUpdateColumn = "city"
	// column name
	BranchesUpdateColumnCreatedDate BranchesUpdateColumn = "created_date"
	// column name
	BranchesUpdateColumnDistributorID BranchesUpdateColumn = "distributor_id"
	// column name
	BranchesUpdateColumnID BranchesUpdateColumn = "id"
	// column name
	BranchesUpdateColumnLocationID BranchesUpdateColumn = "location_id"
	// column name
	BranchesUpdateColumnName BranchesUpdateColumn = "name"
	// column name
	BranchesUpdateColumnProvince BranchesUpdateColumn = "province"
	// column name
	BranchesUpdateColumnUpdatedDate BranchesUpdateColumn = "updated_date"
)

var AllBranchesUpdateColumn = []BranchesUpdateColumn{
	BranchesUpdateColumnAddress,
	BranchesUpdateColumnAreaID,
	BranchesUpdateColumnCity,
	BranchesUpdateColumnCreatedDate,
	BranchesUpdateColumnDistributorID,
	BranchesUpdateColumnID,
	BranchesUpdateColumnLocationID,
	BranchesUpdateColumnName,
	BranchesUpdateColumnProvince,
	BranchesUpdateColumnUpdatedDate,
}

func (e BranchesUpdateColumn) IsValid() bool {
	switch e {
	case BranchesUpdateColumnAddress, BranchesUpdateColumnAreaID, BranchesUpdateColumnCity, BranchesUpdateColumnCreatedDate, BranchesUpdateColumnDistributorID, BranchesUpdateColumnID, BranchesUpdateColumnLocationID, BranchesUpdateColumnName, BranchesUpdateColumnProvince, BranchesUpdateColumnUpdatedDate:
		return true
	}
	return false
}

func (e BranchesUpdateColumn) String() string {
	return string(e)
}

func (e *BranchesUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BranchesUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid branches_update_column", str)
	}
	return nil
}

func (e BranchesUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "contracts"
type ContractsConstraint string

const (
	// unique or primary key constraint
	ContractsConstraintContractsPkey ContractsConstraint = "contracts_pkey"
)

var AllContractsConstraint = []ContractsConstraint{
	ContractsConstraintContractsPkey,
}

func (e ContractsConstraint) IsValid() bool {
	switch e {
	case ContractsConstraintContractsPkey:
		return true
	}
	return false
}

func (e ContractsConstraint) String() string {
	return string(e)
}

func (e *ContractsConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ContractsConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid contracts_constraint", str)
	}
	return nil
}

func (e ContractsConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "contracts"
type ContractsSelectColumn string

const (
	// column name
	ContractsSelectColumnID ContractsSelectColumn = "id"
	// column name
	ContractsSelectColumnRenewalDate ContractsSelectColumn = "renewal_date"
	// column name
	ContractsSelectColumnRenewalDuration ContractsSelectColumn = "renewal_duration"
	// column name
	ContractsSelectColumnStartDate ContractsSelectColumn = "start_date"
	// column name
	ContractsSelectColumnUserID ContractsSelectColumn = "user_id"
)

var AllContractsSelectColumn = []ContractsSelectColumn{
	ContractsSelectColumnID,
	ContractsSelectColumnRenewalDate,
	ContractsSelectColumnRenewalDuration,
	ContractsSelectColumnStartDate,
	ContractsSelectColumnUserID,
}

func (e ContractsSelectColumn) IsValid() bool {
	switch e {
	case ContractsSelectColumnID, ContractsSelectColumnRenewalDate, ContractsSelectColumnRenewalDuration, ContractsSelectColumnStartDate, ContractsSelectColumnUserID:
		return true
	}
	return false
}

func (e ContractsSelectColumn) String() string {
	return string(e)
}

func (e *ContractsSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ContractsSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid contracts_select_column", str)
	}
	return nil
}

func (e ContractsSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "contracts"
type ContractsUpdateColumn string

const (
	// column name
	ContractsUpdateColumnID ContractsUpdateColumn = "id"
	// column name
	ContractsUpdateColumnRenewalDate ContractsUpdateColumn = "renewal_date"
	// column name
	ContractsUpdateColumnRenewalDuration ContractsUpdateColumn = "renewal_duration"
	// column name
	ContractsUpdateColumnStartDate ContractsUpdateColumn = "start_date"
	// column name
	ContractsUpdateColumnUserID ContractsUpdateColumn = "user_id"
)

var AllContractsUpdateColumn = []ContractsUpdateColumn{
	ContractsUpdateColumnID,
	ContractsUpdateColumnRenewalDate,
	ContractsUpdateColumnRenewalDuration,
	ContractsUpdateColumnStartDate,
	ContractsUpdateColumnUserID,
}

func (e ContractsUpdateColumn) IsValid() bool {
	switch e {
	case ContractsUpdateColumnID, ContractsUpdateColumnRenewalDate, ContractsUpdateColumnRenewalDuration, ContractsUpdateColumnStartDate, ContractsUpdateColumnUserID:
		return true
	}
	return false
}

func (e ContractsUpdateColumn) String() string {
	return string(e)
}

func (e *ContractsUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ContractsUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid contracts_update_column", str)
	}
	return nil
}

func (e ContractsUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "distributors"
type DistributorsConstraint string

const (
	// unique or primary key constraint
	DistributorsConstraintDistributorsNameKey DistributorsConstraint = "distributors_name_key"
	// unique or primary key constraint
	DistributorsConstraintDistributorsPkey DistributorsConstraint = "distributors_pkey"
)

var AllDistributorsConstraint = []DistributorsConstraint{
	DistributorsConstraintDistributorsNameKey,
	DistributorsConstraintDistributorsPkey,
}

func (e DistributorsConstraint) IsValid() bool {
	switch e {
	case DistributorsConstraintDistributorsNameKey, DistributorsConstraintDistributorsPkey:
		return true
	}
	return false
}

func (e DistributorsConstraint) String() string {
	return string(e)
}

func (e *DistributorsConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DistributorsConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid distributors_constraint", str)
	}
	return nil
}

func (e DistributorsConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "distributors"
type DistributorsSelectColumn string

const (
	// column name
	DistributorsSelectColumnAreaID DistributorsSelectColumn = "area_id"
	// column name
	DistributorsSelectColumnCreatedAt DistributorsSelectColumn = "created_at"
	// column name
	DistributorsSelectColumnEndDate DistributorsSelectColumn = "end_date"
	// column name
	DistributorsSelectColumnHqAddress DistributorsSelectColumn = "hq_address"
	// column name
	DistributorsSelectColumnHqCity DistributorsSelectColumn = "hq_city"
	// column name
	DistributorsSelectColumnHqProvince DistributorsSelectColumn = "hq_province"
	// column name
	DistributorsSelectColumnID DistributorsSelectColumn = "id"
	// column name
	DistributorsSelectColumnIsAssignable DistributorsSelectColumn = "is_assignable"
	// column name
	DistributorsSelectColumnIsEnabled DistributorsSelectColumn = "is_enabled"
	// column name
	DistributorsSelectColumnName DistributorsSelectColumn = "name"
	// column name
	DistributorsSelectColumnStartDate DistributorsSelectColumn = "start_date"
	// column name
	DistributorsSelectColumnUpdatedAt DistributorsSelectColumn = "updated_at"
)

var AllDistributorsSelectColumn = []DistributorsSelectColumn{
	DistributorsSelectColumnAreaID,
	DistributorsSelectColumnCreatedAt,
	DistributorsSelectColumnEndDate,
	DistributorsSelectColumnHqAddress,
	DistributorsSelectColumnHqCity,
	DistributorsSelectColumnHqProvince,
	DistributorsSelectColumnID,
	DistributorsSelectColumnIsAssignable,
	DistributorsSelectColumnIsEnabled,
	DistributorsSelectColumnName,
	DistributorsSelectColumnStartDate,
	DistributorsSelectColumnUpdatedAt,
}

func (e DistributorsSelectColumn) IsValid() bool {
	switch e {
	case DistributorsSelectColumnAreaID, DistributorsSelectColumnCreatedAt, DistributorsSelectColumnEndDate, DistributorsSelectColumnHqAddress, DistributorsSelectColumnHqCity, DistributorsSelectColumnHqProvince, DistributorsSelectColumnID, DistributorsSelectColumnIsAssignable, DistributorsSelectColumnIsEnabled, DistributorsSelectColumnName, DistributorsSelectColumnStartDate, DistributorsSelectColumnUpdatedAt:
		return true
	}
	return false
}

func (e DistributorsSelectColumn) String() string {
	return string(e)
}

func (e *DistributorsSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DistributorsSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid distributors_select_column", str)
	}
	return nil
}

func (e DistributorsSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "distributors"
type DistributorsUpdateColumn string

const (
	// column name
	DistributorsUpdateColumnAreaID DistributorsUpdateColumn = "area_id"
	// column name
	DistributorsUpdateColumnCreatedAt DistributorsUpdateColumn = "created_at"
	// column name
	DistributorsUpdateColumnEndDate DistributorsUpdateColumn = "end_date"
	// column name
	DistributorsUpdateColumnHqAddress DistributorsUpdateColumn = "hq_address"
	// column name
	DistributorsUpdateColumnHqCity DistributorsUpdateColumn = "hq_city"
	// column name
	DistributorsUpdateColumnHqProvince DistributorsUpdateColumn = "hq_province"
	// column name
	DistributorsUpdateColumnID DistributorsUpdateColumn = "id"
	// column name
	DistributorsUpdateColumnIsAssignable DistributorsUpdateColumn = "is_assignable"
	// column name
	DistributorsUpdateColumnIsEnabled DistributorsUpdateColumn = "is_enabled"
	// column name
	DistributorsUpdateColumnName DistributorsUpdateColumn = "name"
	// column name
	DistributorsUpdateColumnStartDate DistributorsUpdateColumn = "start_date"
	// column name
	DistributorsUpdateColumnUpdatedAt DistributorsUpdateColumn = "updated_at"
)

var AllDistributorsUpdateColumn = []DistributorsUpdateColumn{
	DistributorsUpdateColumnAreaID,
	DistributorsUpdateColumnCreatedAt,
	DistributorsUpdateColumnEndDate,
	DistributorsUpdateColumnHqAddress,
	DistributorsUpdateColumnHqCity,
	DistributorsUpdateColumnHqProvince,
	DistributorsUpdateColumnID,
	DistributorsUpdateColumnIsAssignable,
	DistributorsUpdateColumnIsEnabled,
	DistributorsUpdateColumnName,
	DistributorsUpdateColumnStartDate,
	DistributorsUpdateColumnUpdatedAt,
}

func (e DistributorsUpdateColumn) IsValid() bool {
	switch e {
	case DistributorsUpdateColumnAreaID, DistributorsUpdateColumnCreatedAt, DistributorsUpdateColumnEndDate, DistributorsUpdateColumnHqAddress, DistributorsUpdateColumnHqCity, DistributorsUpdateColumnHqProvince, DistributorsUpdateColumnID, DistributorsUpdateColumnIsAssignable, DistributorsUpdateColumnIsEnabled, DistributorsUpdateColumnName, DistributorsUpdateColumnStartDate, DistributorsUpdateColumnUpdatedAt:
		return true
	}
	return false
}

func (e DistributorsUpdateColumn) String() string {
	return string(e)
}

func (e *DistributorsUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DistributorsUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid distributors_update_column", str)
	}
	return nil
}

func (e DistributorsUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "distro_store_assignments"
type DistroStoreAssignmentsConstraint string

const (
	// unique or primary key constraint
	DistroStoreAssignmentsConstraintDistroStoreAssignmentsBranchIDKey DistroStoreAssignmentsConstraint = "distro_store_assignments_branch_id_key"
	// unique or primary key constraint
	DistroStoreAssignmentsConstraintDistroStoreAssignmentsMateStoreIDKey DistroStoreAssignmentsConstraint = "distro_store_assignments_mate_store_id_key"
	// unique or primary key constraint
	DistroStoreAssignmentsConstraintDistroStoreAssignmentsPkey DistroStoreAssignmentsConstraint = "distro_store_assignments_pkey"
)

var AllDistroStoreAssignmentsConstraint = []DistroStoreAssignmentsConstraint{
	DistroStoreAssignmentsConstraintDistroStoreAssignmentsBranchIDKey,
	DistroStoreAssignmentsConstraintDistroStoreAssignmentsMateStoreIDKey,
	DistroStoreAssignmentsConstraintDistroStoreAssignmentsPkey,
}

func (e DistroStoreAssignmentsConstraint) IsValid() bool {
	switch e {
	case DistroStoreAssignmentsConstraintDistroStoreAssignmentsBranchIDKey, DistroStoreAssignmentsConstraintDistroStoreAssignmentsMateStoreIDKey, DistroStoreAssignmentsConstraintDistroStoreAssignmentsPkey:
		return true
	}
	return false
}

func (e DistroStoreAssignmentsConstraint) String() string {
	return string(e)
}

func (e *DistroStoreAssignmentsConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DistroStoreAssignmentsConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid distro_store_assignments_constraint", str)
	}
	return nil
}

func (e DistroStoreAssignmentsConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "distro_store_assignments"
type DistroStoreAssignmentsSelectColumn string

const (
	// column name
	DistroStoreAssignmentsSelectColumnBranchID DistroStoreAssignmentsSelectColumn = "branch_id"
	// column name
	DistroStoreAssignmentsSelectColumnID DistroStoreAssignmentsSelectColumn = "id"
	// column name
	DistroStoreAssignmentsSelectColumnMateStoreID DistroStoreAssignmentsSelectColumn = "mate_store_id"
	// column name
	DistroStoreAssignmentsSelectColumnUserID DistroStoreAssignmentsSelectColumn = "user_id"
)

var AllDistroStoreAssignmentsSelectColumn = []DistroStoreAssignmentsSelectColumn{
	DistroStoreAssignmentsSelectColumnBranchID,
	DistroStoreAssignmentsSelectColumnID,
	DistroStoreAssignmentsSelectColumnMateStoreID,
	DistroStoreAssignmentsSelectColumnUserID,
}

func (e DistroStoreAssignmentsSelectColumn) IsValid() bool {
	switch e {
	case DistroStoreAssignmentsSelectColumnBranchID, DistroStoreAssignmentsSelectColumnID, DistroStoreAssignmentsSelectColumnMateStoreID, DistroStoreAssignmentsSelectColumnUserID:
		return true
	}
	return false
}

func (e DistroStoreAssignmentsSelectColumn) String() string {
	return string(e)
}

func (e *DistroStoreAssignmentsSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DistroStoreAssignmentsSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid distro_store_assignments_select_column", str)
	}
	return nil
}

func (e DistroStoreAssignmentsSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "distro_store_assignments"
type DistroStoreAssignmentsUpdateColumn string

const (
	// column name
	DistroStoreAssignmentsUpdateColumnBranchID DistroStoreAssignmentsUpdateColumn = "branch_id"
	// column name
	DistroStoreAssignmentsUpdateColumnID DistroStoreAssignmentsUpdateColumn = "id"
	// column name
	DistroStoreAssignmentsUpdateColumnMateStoreID DistroStoreAssignmentsUpdateColumn = "mate_store_id"
	// column name
	DistroStoreAssignmentsUpdateColumnUserID DistroStoreAssignmentsUpdateColumn = "user_id"
)

var AllDistroStoreAssignmentsUpdateColumn = []DistroStoreAssignmentsUpdateColumn{
	DistroStoreAssignmentsUpdateColumnBranchID,
	DistroStoreAssignmentsUpdateColumnID,
	DistroStoreAssignmentsUpdateColumnMateStoreID,
	DistroStoreAssignmentsUpdateColumnUserID,
}

func (e DistroStoreAssignmentsUpdateColumn) IsValid() bool {
	switch e {
	case DistroStoreAssignmentsUpdateColumnBranchID, DistroStoreAssignmentsUpdateColumnID, DistroStoreAssignmentsUpdateColumnMateStoreID, DistroStoreAssignmentsUpdateColumnUserID:
		return true
	}
	return false
}

func (e DistroStoreAssignmentsUpdateColumn) String() string {
	return string(e)
}

func (e *DistroStoreAssignmentsUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DistroStoreAssignmentsUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid distro_store_assignments_update_column", str)
	}
	return nil
}

func (e DistroStoreAssignmentsUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "inventories"
type InventoriesConstraint string

const (
	// unique or primary key constraint
	InventoriesConstraintInventoriesBranchIDKey InventoriesConstraint = "inventories_branch_id_key"
	// unique or primary key constraint
	InventoriesConstraintInventoriesMateStoreIDKey InventoriesConstraint = "inventories_mate_store_id_key"
	// unique or primary key constraint
	InventoriesConstraintInventoriesPkey InventoriesConstraint = "inventories_pkey"
)

var AllInventoriesConstraint = []InventoriesConstraint{
	InventoriesConstraintInventoriesBranchIDKey,
	InventoriesConstraintInventoriesMateStoreIDKey,
	InventoriesConstraintInventoriesPkey,
}

func (e InventoriesConstraint) IsValid() bool {
	switch e {
	case InventoriesConstraintInventoriesBranchIDKey, InventoriesConstraintInventoriesMateStoreIDKey, InventoriesConstraintInventoriesPkey:
		return true
	}
	return false
}

func (e InventoriesConstraint) String() string {
	return string(e)
}

func (e *InventoriesConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InventoriesConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid inventories_constraint", str)
	}
	return nil
}

func (e InventoriesConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "inventories"
type InventoriesSelectColumn string

const (
	// column name
	InventoriesSelectColumnArrivalDate InventoriesSelectColumn = "arrival_date"
	// column name
	InventoriesSelectColumnBranchID InventoriesSelectColumn = "branch_id"
	// column name
	InventoriesSelectColumnExpiryDate InventoriesSelectColumn = "expiry_date"
	// column name
	InventoriesSelectColumnID InventoriesSelectColumn = "id"
	// column name
	InventoriesSelectColumnMateStoreID InventoriesSelectColumn = "mate_store_id"
	// column name
	InventoriesSelectColumnProductID InventoriesSelectColumn = "product_id"
	// column name
	InventoriesSelectColumnQty InventoriesSelectColumn = "qty"
)

var AllInventoriesSelectColumn = []InventoriesSelectColumn{
	InventoriesSelectColumnArrivalDate,
	InventoriesSelectColumnBranchID,
	InventoriesSelectColumnExpiryDate,
	InventoriesSelectColumnID,
	InventoriesSelectColumnMateStoreID,
	InventoriesSelectColumnProductID,
	InventoriesSelectColumnQty,
}

func (e InventoriesSelectColumn) IsValid() bool {
	switch e {
	case InventoriesSelectColumnArrivalDate, InventoriesSelectColumnBranchID, InventoriesSelectColumnExpiryDate, InventoriesSelectColumnID, InventoriesSelectColumnMateStoreID, InventoriesSelectColumnProductID, InventoriesSelectColumnQty:
		return true
	}
	return false
}

func (e InventoriesSelectColumn) String() string {
	return string(e)
}

func (e *InventoriesSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InventoriesSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid inventories_select_column", str)
	}
	return nil
}

func (e InventoriesSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "inventories"
type InventoriesUpdateColumn string

const (
	// column name
	InventoriesUpdateColumnArrivalDate InventoriesUpdateColumn = "arrival_date"
	// column name
	InventoriesUpdateColumnBranchID InventoriesUpdateColumn = "branch_id"
	// column name
	InventoriesUpdateColumnExpiryDate InventoriesUpdateColumn = "expiry_date"
	// column name
	InventoriesUpdateColumnID InventoriesUpdateColumn = "id"
	// column name
	InventoriesUpdateColumnMateStoreID InventoriesUpdateColumn = "mate_store_id"
	// column name
	InventoriesUpdateColumnProductID InventoriesUpdateColumn = "product_id"
	// column name
	InventoriesUpdateColumnQty InventoriesUpdateColumn = "qty"
)

var AllInventoriesUpdateColumn = []InventoriesUpdateColumn{
	InventoriesUpdateColumnArrivalDate,
	InventoriesUpdateColumnBranchID,
	InventoriesUpdateColumnExpiryDate,
	InventoriesUpdateColumnID,
	InventoriesUpdateColumnMateStoreID,
	InventoriesUpdateColumnProductID,
	InventoriesUpdateColumnQty,
}

func (e InventoriesUpdateColumn) IsValid() bool {
	switch e {
	case InventoriesUpdateColumnArrivalDate, InventoriesUpdateColumnBranchID, InventoriesUpdateColumnExpiryDate, InventoriesUpdateColumnID, InventoriesUpdateColumnMateStoreID, InventoriesUpdateColumnProductID, InventoriesUpdateColumnQty:
		return true
	}
	return false
}

func (e InventoriesUpdateColumn) String() string {
	return string(e)
}

func (e *InventoriesUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InventoriesUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid inventories_update_column", str)
	}
	return nil
}

func (e InventoriesUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "locations"
type LocationsConstraint string

const (
	// unique or primary key constraint
	LocationsConstraintLocationsGeoLocKey LocationsConstraint = "locations_geo_loc_key"
	// unique or primary key constraint
	LocationsConstraintLocationsNameKey LocationsConstraint = "locations_name_key"
	// unique or primary key constraint
	LocationsConstraintLocationsPkey LocationsConstraint = "locations_pkey"
)

var AllLocationsConstraint = []LocationsConstraint{
	LocationsConstraintLocationsGeoLocKey,
	LocationsConstraintLocationsNameKey,
	LocationsConstraintLocationsPkey,
}

func (e LocationsConstraint) IsValid() bool {
	switch e {
	case LocationsConstraintLocationsGeoLocKey, LocationsConstraintLocationsNameKey, LocationsConstraintLocationsPkey:
		return true
	}
	return false
}

func (e LocationsConstraint) String() string {
	return string(e)
}

func (e *LocationsConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LocationsConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid locations_constraint", str)
	}
	return nil
}

func (e LocationsConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "locations"
type LocationsSelectColumn string

const (
	// column name
	LocationsSelectColumnGeoLoc LocationsSelectColumn = "geo_loc"
	// column name
	LocationsSelectColumnID LocationsSelectColumn = "id"
	// column name
	LocationsSelectColumnName LocationsSelectColumn = "name"
)

var AllLocationsSelectColumn = []LocationsSelectColumn{
	LocationsSelectColumnGeoLoc,
	LocationsSelectColumnID,
	LocationsSelectColumnName,
}

func (e LocationsSelectColumn) IsValid() bool {
	switch e {
	case LocationsSelectColumnGeoLoc, LocationsSelectColumnID, LocationsSelectColumnName:
		return true
	}
	return false
}

func (e LocationsSelectColumn) String() string {
	return string(e)
}

func (e *LocationsSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LocationsSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid locations_select_column", str)
	}
	return nil
}

func (e LocationsSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "locations"
type LocationsUpdateColumn string

const (
	// column name
	LocationsUpdateColumnGeoLoc LocationsUpdateColumn = "geo_loc"
	// column name
	LocationsUpdateColumnID LocationsUpdateColumn = "id"
	// column name
	LocationsUpdateColumnName LocationsUpdateColumn = "name"
)

var AllLocationsUpdateColumn = []LocationsUpdateColumn{
	LocationsUpdateColumnGeoLoc,
	LocationsUpdateColumnID,
	LocationsUpdateColumnName,
}

func (e LocationsUpdateColumn) IsValid() bool {
	switch e {
	case LocationsUpdateColumnGeoLoc, LocationsUpdateColumnID, LocationsUpdateColumnName:
		return true
	}
	return false
}

func (e LocationsUpdateColumn) String() string {
	return string(e)
}

func (e *LocationsUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LocationsUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid locations_update_column", str)
	}
	return nil
}

func (e LocationsUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "marketing_regions"
type MarketingRegionsConstraint string

const (
	// unique or primary key constraint
	MarketingRegionsConstraintMarketingRegionsPkey MarketingRegionsConstraint = "marketing_regions_pkey"
	// unique or primary key constraint
	MarketingRegionsConstraintMarketingRegionsRegionCodeKey MarketingRegionsConstraint = "marketing_regions_region_code_key"
)

var AllMarketingRegionsConstraint = []MarketingRegionsConstraint{
	MarketingRegionsConstraintMarketingRegionsPkey,
	MarketingRegionsConstraintMarketingRegionsRegionCodeKey,
}

func (e MarketingRegionsConstraint) IsValid() bool {
	switch e {
	case MarketingRegionsConstraintMarketingRegionsPkey, MarketingRegionsConstraintMarketingRegionsRegionCodeKey:
		return true
	}
	return false
}

func (e MarketingRegionsConstraint) String() string {
	return string(e)
}

func (e *MarketingRegionsConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MarketingRegionsConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid marketing_regions_constraint", str)
	}
	return nil
}

func (e MarketingRegionsConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "marketing_regions"
type MarketingRegionsSelectColumn string

const (
	// column name
	MarketingRegionsSelectColumnID MarketingRegionsSelectColumn = "id"
	// column name
	MarketingRegionsSelectColumnNotes MarketingRegionsSelectColumn = "notes"
	// column name
	MarketingRegionsSelectColumnRegionCode MarketingRegionsSelectColumn = "region_code"
)

var AllMarketingRegionsSelectColumn = []MarketingRegionsSelectColumn{
	MarketingRegionsSelectColumnID,
	MarketingRegionsSelectColumnNotes,
	MarketingRegionsSelectColumnRegionCode,
}

func (e MarketingRegionsSelectColumn) IsValid() bool {
	switch e {
	case MarketingRegionsSelectColumnID, MarketingRegionsSelectColumnNotes, MarketingRegionsSelectColumnRegionCode:
		return true
	}
	return false
}

func (e MarketingRegionsSelectColumn) String() string {
	return string(e)
}

func (e *MarketingRegionsSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MarketingRegionsSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid marketing_regions_select_column", str)
	}
	return nil
}

func (e MarketingRegionsSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "marketing_regions"
type MarketingRegionsUpdateColumn string

const (
	// column name
	MarketingRegionsUpdateColumnID MarketingRegionsUpdateColumn = "id"
	// column name
	MarketingRegionsUpdateColumnNotes MarketingRegionsUpdateColumn = "notes"
	// column name
	MarketingRegionsUpdateColumnRegionCode MarketingRegionsUpdateColumn = "region_code"
)

var AllMarketingRegionsUpdateColumn = []MarketingRegionsUpdateColumn{
	MarketingRegionsUpdateColumnID,
	MarketingRegionsUpdateColumnNotes,
	MarketingRegionsUpdateColumnRegionCode,
}

func (e MarketingRegionsUpdateColumn) IsValid() bool {
	switch e {
	case MarketingRegionsUpdateColumnID, MarketingRegionsUpdateColumnNotes, MarketingRegionsUpdateColumnRegionCode:
		return true
	}
	return false
}

func (e MarketingRegionsUpdateColumn) String() string {
	return string(e)
}

func (e *MarketingRegionsUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MarketingRegionsUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid marketing_regions_update_column", str)
	}
	return nil
}

func (e MarketingRegionsUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "mate_stores"
type MateStoresConstraint string

const (
	// unique or primary key constraint
	MateStoresConstraintMateStoresNameKey MateStoresConstraint = "mate_stores_name_key"
	// unique or primary key constraint
	MateStoresConstraintMateStoresPkey MateStoresConstraint = "mate_stores_pkey"
)

var AllMateStoresConstraint = []MateStoresConstraint{
	MateStoresConstraintMateStoresNameKey,
	MateStoresConstraintMateStoresPkey,
}

func (e MateStoresConstraint) IsValid() bool {
	switch e {
	case MateStoresConstraintMateStoresNameKey, MateStoresConstraintMateStoresPkey:
		return true
	}
	return false
}

func (e MateStoresConstraint) String() string {
	return string(e)
}

func (e *MateStoresConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MateStoresConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid mate_stores_constraint", str)
	}
	return nil
}

func (e MateStoresConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "mate_stores"
type MateStoresSelectColumn string

const (
	// column name
	MateStoresSelectColumnAddress MateStoresSelectColumn = "address"
	// column name
	MateStoresSelectColumnCity MateStoresSelectColumn = "city"
	// column name
	MateStoresSelectColumnCreatedAt MateStoresSelectColumn = "created_at"
	// column name
	MateStoresSelectColumnEndDate MateStoresSelectColumn = "end_date"
	// column name
	MateStoresSelectColumnID MateStoresSelectColumn = "id"
	// column name
	MateStoresSelectColumnIsEnabled MateStoresSelectColumn = "is_enabled"
	// column name
	MateStoresSelectColumnLocationID MateStoresSelectColumn = "location_id"
	// column name
	MateStoresSelectColumnName MateStoresSelectColumn = "name"
	// column name
	MateStoresSelectColumnProvince MateStoresSelectColumn = "province"
	// column name
	MateStoresSelectColumnStartDate MateStoresSelectColumn = "start_date"
	// column name
	MateStoresSelectColumnSupplierID MateStoresSelectColumn = "supplier_id"
	// column name
	MateStoresSelectColumnUpdatedAt MateStoresSelectColumn = "updated_at"
)

var AllMateStoresSelectColumn = []MateStoresSelectColumn{
	MateStoresSelectColumnAddress,
	MateStoresSelectColumnCity,
	MateStoresSelectColumnCreatedAt,
	MateStoresSelectColumnEndDate,
	MateStoresSelectColumnID,
	MateStoresSelectColumnIsEnabled,
	MateStoresSelectColumnLocationID,
	MateStoresSelectColumnName,
	MateStoresSelectColumnProvince,
	MateStoresSelectColumnStartDate,
	MateStoresSelectColumnSupplierID,
	MateStoresSelectColumnUpdatedAt,
}

func (e MateStoresSelectColumn) IsValid() bool {
	switch e {
	case MateStoresSelectColumnAddress, MateStoresSelectColumnCity, MateStoresSelectColumnCreatedAt, MateStoresSelectColumnEndDate, MateStoresSelectColumnID, MateStoresSelectColumnIsEnabled, MateStoresSelectColumnLocationID, MateStoresSelectColumnName, MateStoresSelectColumnProvince, MateStoresSelectColumnStartDate, MateStoresSelectColumnSupplierID, MateStoresSelectColumnUpdatedAt:
		return true
	}
	return false
}

func (e MateStoresSelectColumn) String() string {
	return string(e)
}

func (e *MateStoresSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MateStoresSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid mate_stores_select_column", str)
	}
	return nil
}

func (e MateStoresSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "mate_stores"
type MateStoresUpdateColumn string

const (
	// column name
	MateStoresUpdateColumnAddress MateStoresUpdateColumn = "address"
	// column name
	MateStoresUpdateColumnCity MateStoresUpdateColumn = "city"
	// column name
	MateStoresUpdateColumnCreatedAt MateStoresUpdateColumn = "created_at"
	// column name
	MateStoresUpdateColumnEndDate MateStoresUpdateColumn = "end_date"
	// column name
	MateStoresUpdateColumnID MateStoresUpdateColumn = "id"
	// column name
	MateStoresUpdateColumnIsEnabled MateStoresUpdateColumn = "is_enabled"
	// column name
	MateStoresUpdateColumnLocationID MateStoresUpdateColumn = "location_id"
	// column name
	MateStoresUpdateColumnName MateStoresUpdateColumn = "name"
	// column name
	MateStoresUpdateColumnProvince MateStoresUpdateColumn = "province"
	// column name
	MateStoresUpdateColumnStartDate MateStoresUpdateColumn = "start_date"
	// column name
	MateStoresUpdateColumnSupplierID MateStoresUpdateColumn = "supplier_id"
	// column name
	MateStoresUpdateColumnUpdatedAt MateStoresUpdateColumn = "updated_at"
)

var AllMateStoresUpdateColumn = []MateStoresUpdateColumn{
	MateStoresUpdateColumnAddress,
	MateStoresUpdateColumnCity,
	MateStoresUpdateColumnCreatedAt,
	MateStoresUpdateColumnEndDate,
	MateStoresUpdateColumnID,
	MateStoresUpdateColumnIsEnabled,
	MateStoresUpdateColumnLocationID,
	MateStoresUpdateColumnName,
	MateStoresUpdateColumnProvince,
	MateStoresUpdateColumnStartDate,
	MateStoresUpdateColumnSupplierID,
	MateStoresUpdateColumnUpdatedAt,
}

func (e MateStoresUpdateColumn) IsValid() bool {
	switch e {
	case MateStoresUpdateColumnAddress, MateStoresUpdateColumnCity, MateStoresUpdateColumnCreatedAt, MateStoresUpdateColumnEndDate, MateStoresUpdateColumnID, MateStoresUpdateColumnIsEnabled, MateStoresUpdateColumnLocationID, MateStoresUpdateColumnName, MateStoresUpdateColumnProvince, MateStoresUpdateColumnStartDate, MateStoresUpdateColumnSupplierID, MateStoresUpdateColumnUpdatedAt:
		return true
	}
	return false
}

func (e MateStoresUpdateColumn) String() string {
	return string(e)
}

func (e *MateStoresUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MateStoresUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid mate_stores_update_column", str)
	}
	return nil
}

func (e MateStoresUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// column ordering options
type OrderBy string

const (
	// in the ascending order, nulls last
	OrderByAsc OrderBy = "asc"
	// in the ascending order, nulls first
	OrderByAscNullsFirst OrderBy = "asc_nulls_first"
	// in the ascending order, nulls last
	OrderByAscNullsLast OrderBy = "asc_nulls_last"
	// in the descending order, nulls first
	OrderByDesc OrderBy = "desc"
	// in the descending order, nulls first
	OrderByDescNullsFirst OrderBy = "desc_nulls_first"
	// in the descending order, nulls last
	OrderByDescNullsLast OrderBy = "desc_nulls_last"
)

var AllOrderBy = []OrderBy{
	OrderByAsc,
	OrderByAscNullsFirst,
	OrderByAscNullsLast,
	OrderByDesc,
	OrderByDescNullsFirst,
	OrderByDescNullsLast,
}

func (e OrderBy) IsValid() bool {
	switch e {
	case OrderByAsc, OrderByAscNullsFirst, OrderByAscNullsLast, OrderByDesc, OrderByDescNullsFirst, OrderByDescNullsLast:
		return true
	}
	return false
}

func (e OrderBy) String() string {
	return string(e)
}

func (e *OrderBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid order_by", str)
	}
	return nil
}

func (e OrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "product_categories"
type ProductCategoriesConstraint string

const (
	// unique or primary key constraint
	ProductCategoriesConstraintProductCategoriesNameKey ProductCategoriesConstraint = "product_categories_name_key"
	// unique or primary key constraint
	ProductCategoriesConstraintProductCategoriesPkey ProductCategoriesConstraint = "product_categories_pkey"
)

var AllProductCategoriesConstraint = []ProductCategoriesConstraint{
	ProductCategoriesConstraintProductCategoriesNameKey,
	ProductCategoriesConstraintProductCategoriesPkey,
}

func (e ProductCategoriesConstraint) IsValid() bool {
	switch e {
	case ProductCategoriesConstraintProductCategoriesNameKey, ProductCategoriesConstraintProductCategoriesPkey:
		return true
	}
	return false
}

func (e ProductCategoriesConstraint) String() string {
	return string(e)
}

func (e *ProductCategoriesConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductCategoriesConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid product_categories_constraint", str)
	}
	return nil
}

func (e ProductCategoriesConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "product_categories"
type ProductCategoriesSelectColumn string

const (
	// column name
	ProductCategoriesSelectColumnID ProductCategoriesSelectColumn = "id"
	// column name
	ProductCategoriesSelectColumnName ProductCategoriesSelectColumn = "name"
)

var AllProductCategoriesSelectColumn = []ProductCategoriesSelectColumn{
	ProductCategoriesSelectColumnID,
	ProductCategoriesSelectColumnName,
}

func (e ProductCategoriesSelectColumn) IsValid() bool {
	switch e {
	case ProductCategoriesSelectColumnID, ProductCategoriesSelectColumnName:
		return true
	}
	return false
}

func (e ProductCategoriesSelectColumn) String() string {
	return string(e)
}

func (e *ProductCategoriesSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductCategoriesSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid product_categories_select_column", str)
	}
	return nil
}

func (e ProductCategoriesSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "product_categories"
type ProductCategoriesUpdateColumn string

const (
	// column name
	ProductCategoriesUpdateColumnID ProductCategoriesUpdateColumn = "id"
	// column name
	ProductCategoriesUpdateColumnName ProductCategoriesUpdateColumn = "name"
)

var AllProductCategoriesUpdateColumn = []ProductCategoriesUpdateColumn{
	ProductCategoriesUpdateColumnID,
	ProductCategoriesUpdateColumnName,
}

func (e ProductCategoriesUpdateColumn) IsValid() bool {
	switch e {
	case ProductCategoriesUpdateColumnID, ProductCategoriesUpdateColumnName:
		return true
	}
	return false
}

func (e ProductCategoriesUpdateColumn) String() string {
	return string(e)
}

func (e *ProductCategoriesUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductCategoriesUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid product_categories_update_column", str)
	}
	return nil
}

func (e ProductCategoriesUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "product_packagings"
type ProductPackagingsConstraint string

const (
	// unique or primary key constraint
	ProductPackagingsConstraintProductPackagingsPkey ProductPackagingsConstraint = "product_packagings_pkey"
)

var AllProductPackagingsConstraint = []ProductPackagingsConstraint{
	ProductPackagingsConstraintProductPackagingsPkey,
}

func (e ProductPackagingsConstraint) IsValid() bool {
	switch e {
	case ProductPackagingsConstraintProductPackagingsPkey:
		return true
	}
	return false
}

func (e ProductPackagingsConstraint) String() string {
	return string(e)
}

func (e *ProductPackagingsConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductPackagingsConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid product_packagings_constraint", str)
	}
	return nil
}

func (e ProductPackagingsConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "product_packagings"
type ProductPackagingsSelectColumn string

const (
	// column name
	ProductPackagingsSelectColumnID ProductPackagingsSelectColumn = "id"
	// column name
	ProductPackagingsSelectColumnNotes ProductPackagingsSelectColumn = "notes"
	// column name
	ProductPackagingsSelectColumnUnit ProductPackagingsSelectColumn = "unit"
)

var AllProductPackagingsSelectColumn = []ProductPackagingsSelectColumn{
	ProductPackagingsSelectColumnID,
	ProductPackagingsSelectColumnNotes,
	ProductPackagingsSelectColumnUnit,
}

func (e ProductPackagingsSelectColumn) IsValid() bool {
	switch e {
	case ProductPackagingsSelectColumnID, ProductPackagingsSelectColumnNotes, ProductPackagingsSelectColumnUnit:
		return true
	}
	return false
}

func (e ProductPackagingsSelectColumn) String() string {
	return string(e)
}

func (e *ProductPackagingsSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductPackagingsSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid product_packagings_select_column", str)
	}
	return nil
}

func (e ProductPackagingsSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "product_packagings"
type ProductPackagingsUpdateColumn string

const (
	// column name
	ProductPackagingsUpdateColumnID ProductPackagingsUpdateColumn = "id"
	// column name
	ProductPackagingsUpdateColumnNotes ProductPackagingsUpdateColumn = "notes"
	// column name
	ProductPackagingsUpdateColumnUnit ProductPackagingsUpdateColumn = "unit"
)

var AllProductPackagingsUpdateColumn = []ProductPackagingsUpdateColumn{
	ProductPackagingsUpdateColumnID,
	ProductPackagingsUpdateColumnNotes,
	ProductPackagingsUpdateColumnUnit,
}

func (e ProductPackagingsUpdateColumn) IsValid() bool {
	switch e {
	case ProductPackagingsUpdateColumnID, ProductPackagingsUpdateColumnNotes, ProductPackagingsUpdateColumnUnit:
		return true
	}
	return false
}

func (e ProductPackagingsUpdateColumn) String() string {
	return string(e)
}

func (e *ProductPackagingsUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductPackagingsUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid product_packagings_update_column", str)
	}
	return nil
}

func (e ProductPackagingsUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "product_pictures"
type ProductPicturesConstraint string

const (
	// unique or primary key constraint
	ProductPicturesConstraintProductAttributesPkey ProductPicturesConstraint = "product_attributes_pkey"
)

var AllProductPicturesConstraint = []ProductPicturesConstraint{
	ProductPicturesConstraintProductAttributesPkey,
}

func (e ProductPicturesConstraint) IsValid() bool {
	switch e {
	case ProductPicturesConstraintProductAttributesPkey:
		return true
	}
	return false
}

func (e ProductPicturesConstraint) String() string {
	return string(e)
}

func (e *ProductPicturesConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductPicturesConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid product_pictures_constraint", str)
	}
	return nil
}

func (e ProductPicturesConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "product_pictures"
type ProductPicturesSelectColumn string

const (
	// column name
	ProductPicturesSelectColumnExpiry ProductPicturesSelectColumn = "expiry"
	// column name
	ProductPicturesSelectColumnID ProductPicturesSelectColumn = "id"
	// column name
	ProductPicturesSelectColumnPicture ProductPicturesSelectColumn = "picture"
	// column name
	ProductPicturesSelectColumnProductID ProductPicturesSelectColumn = "product_id"
)

var AllProductPicturesSelectColumn = []ProductPicturesSelectColumn{
	ProductPicturesSelectColumnExpiry,
	ProductPicturesSelectColumnID,
	ProductPicturesSelectColumnPicture,
	ProductPicturesSelectColumnProductID,
}

func (e ProductPicturesSelectColumn) IsValid() bool {
	switch e {
	case ProductPicturesSelectColumnExpiry, ProductPicturesSelectColumnID, ProductPicturesSelectColumnPicture, ProductPicturesSelectColumnProductID:
		return true
	}
	return false
}

func (e ProductPicturesSelectColumn) String() string {
	return string(e)
}

func (e *ProductPicturesSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductPicturesSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid product_pictures_select_column", str)
	}
	return nil
}

func (e ProductPicturesSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "product_pictures"
type ProductPicturesUpdateColumn string

const (
	// column name
	ProductPicturesUpdateColumnExpiry ProductPicturesUpdateColumn = "expiry"
	// column name
	ProductPicturesUpdateColumnID ProductPicturesUpdateColumn = "id"
	// column name
	ProductPicturesUpdateColumnPicture ProductPicturesUpdateColumn = "picture"
	// column name
	ProductPicturesUpdateColumnProductID ProductPicturesUpdateColumn = "product_id"
)

var AllProductPicturesUpdateColumn = []ProductPicturesUpdateColumn{
	ProductPicturesUpdateColumnExpiry,
	ProductPicturesUpdateColumnID,
	ProductPicturesUpdateColumnPicture,
	ProductPicturesUpdateColumnProductID,
}

func (e ProductPicturesUpdateColumn) IsValid() bool {
	switch e {
	case ProductPicturesUpdateColumnExpiry, ProductPicturesUpdateColumnID, ProductPicturesUpdateColumnPicture, ProductPicturesUpdateColumnProductID:
		return true
	}
	return false
}

func (e ProductPicturesUpdateColumn) String() string {
	return string(e)
}

func (e *ProductPicturesUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductPicturesUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid product_pictures_update_column", str)
	}
	return nil
}

func (e ProductPicturesUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "products"
type ProductsConstraint string

const (
	// unique or primary key constraint
	ProductsConstraintProductsPkey ProductsConstraint = "products_pkey"
	// unique or primary key constraint
	ProductsConstraintProductsProductCodeKey ProductsConstraint = "products_product_code_key"
	// unique or primary key constraint
	ProductsConstraintProductsVariantKey ProductsConstraint = "products_variant_key"
)

var AllProductsConstraint = []ProductsConstraint{
	ProductsConstraintProductsPkey,
	ProductsConstraintProductsProductCodeKey,
	ProductsConstraintProductsVariantKey,
}

func (e ProductsConstraint) IsValid() bool {
	switch e {
	case ProductsConstraintProductsPkey, ProductsConstraintProductsProductCodeKey, ProductsConstraintProductsVariantKey:
		return true
	}
	return false
}

func (e ProductsConstraint) String() string {
	return string(e)
}

func (e *ProductsConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductsConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid products_constraint", str)
	}
	return nil
}

func (e ProductsConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "products"
type ProductsSelectColumn string

const (
	// column name
	ProductsSelectColumnCategoryID ProductsSelectColumn = "category_id"
	// column name
	ProductsSelectColumnCreatedAt ProductsSelectColumn = "created_at"
	// column name
	ProductsSelectColumnExpiryInterval ProductsSelectColumn = "expiry_interval"
	// column name
	ProductsSelectColumnID ProductsSelectColumn = "id"
	// column name
	ProductsSelectColumnIsActive ProductsSelectColumn = "is_active"
	// column name
	ProductsSelectColumnName ProductsSelectColumn = "name"
	// column name
	ProductsSelectColumnPackagingID ProductsSelectColumn = "packaging_id"
	// column name
	ProductsSelectColumnProductCode ProductsSelectColumn = "product_code"
	// column name
	ProductsSelectColumnProductType ProductsSelectColumn = "product_type"
	// column name
	ProductsSelectColumnSrp ProductsSelectColumn = "srp"
	// column name
	ProductsSelectColumnVariant ProductsSelectColumn = "variant"
)

var AllProductsSelectColumn = []ProductsSelectColumn{
	ProductsSelectColumnCategoryID,
	ProductsSelectColumnCreatedAt,
	ProductsSelectColumnExpiryInterval,
	ProductsSelectColumnID,
	ProductsSelectColumnIsActive,
	ProductsSelectColumnName,
	ProductsSelectColumnPackagingID,
	ProductsSelectColumnProductCode,
	ProductsSelectColumnProductType,
	ProductsSelectColumnSrp,
	ProductsSelectColumnVariant,
}

func (e ProductsSelectColumn) IsValid() bool {
	switch e {
	case ProductsSelectColumnCategoryID, ProductsSelectColumnCreatedAt, ProductsSelectColumnExpiryInterval, ProductsSelectColumnID, ProductsSelectColumnIsActive, ProductsSelectColumnName, ProductsSelectColumnPackagingID, ProductsSelectColumnProductCode, ProductsSelectColumnProductType, ProductsSelectColumnSrp, ProductsSelectColumnVariant:
		return true
	}
	return false
}

func (e ProductsSelectColumn) String() string {
	return string(e)
}

func (e *ProductsSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductsSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid products_select_column", str)
	}
	return nil
}

func (e ProductsSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "products"
type ProductsUpdateColumn string

const (
	// column name
	ProductsUpdateColumnCategoryID ProductsUpdateColumn = "category_id"
	// column name
	ProductsUpdateColumnCreatedAt ProductsUpdateColumn = "created_at"
	// column name
	ProductsUpdateColumnExpiryInterval ProductsUpdateColumn = "expiry_interval"
	// column name
	ProductsUpdateColumnID ProductsUpdateColumn = "id"
	// column name
	ProductsUpdateColumnIsActive ProductsUpdateColumn = "is_active"
	// column name
	ProductsUpdateColumnName ProductsUpdateColumn = "name"
	// column name
	ProductsUpdateColumnPackagingID ProductsUpdateColumn = "packaging_id"
	// column name
	ProductsUpdateColumnProductCode ProductsUpdateColumn = "product_code"
	// column name
	ProductsUpdateColumnProductType ProductsUpdateColumn = "product_type"
	// column name
	ProductsUpdateColumnSrp ProductsUpdateColumn = "srp"
	// column name
	ProductsUpdateColumnVariant ProductsUpdateColumn = "variant"
)

var AllProductsUpdateColumn = []ProductsUpdateColumn{
	ProductsUpdateColumnCategoryID,
	ProductsUpdateColumnCreatedAt,
	ProductsUpdateColumnExpiryInterval,
	ProductsUpdateColumnID,
	ProductsUpdateColumnIsActive,
	ProductsUpdateColumnName,
	ProductsUpdateColumnPackagingID,
	ProductsUpdateColumnProductCode,
	ProductsUpdateColumnProductType,
	ProductsUpdateColumnSrp,
	ProductsUpdateColumnVariant,
}

func (e ProductsUpdateColumn) IsValid() bool {
	switch e {
	case ProductsUpdateColumnCategoryID, ProductsUpdateColumnCreatedAt, ProductsUpdateColumnExpiryInterval, ProductsUpdateColumnID, ProductsUpdateColumnIsActive, ProductsUpdateColumnName, ProductsUpdateColumnPackagingID, ProductsUpdateColumnProductCode, ProductsUpdateColumnProductType, ProductsUpdateColumnSrp, ProductsUpdateColumnVariant:
		return true
	}
	return false
}

func (e ProductsUpdateColumn) String() string {
	return string(e)
}

func (e *ProductsUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductsUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid products_update_column", str)
	}
	return nil
}

func (e ProductsUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "text_result"
type TextResultSelectColumn string

const (
	// column name
	TextResultSelectColumnResult TextResultSelectColumn = "result"
)

var AllTextResultSelectColumn = []TextResultSelectColumn{
	TextResultSelectColumnResult,
}

func (e TextResultSelectColumn) IsValid() bool {
	switch e {
	case TextResultSelectColumnResult:
		return true
	}
	return false
}

func (e TextResultSelectColumn) String() string {
	return string(e)
}

func (e *TextResultSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TextResultSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid text_result_select_column", str)
	}
	return nil
}

func (e TextResultSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "user_pictures"
type UserPicturesConstraint string

const (
	// unique or primary key constraint
	UserPicturesConstraintUserPicturesAccountIDKey UserPicturesConstraint = "user_pictures_account_id_key"
	// unique or primary key constraint
	UserPicturesConstraintUserPicturesPictureURLKey UserPicturesConstraint = "user_pictures_picture_url_key"
	// unique or primary key constraint
	UserPicturesConstraintUserPicturesPkey UserPicturesConstraint = "user_pictures_pkey"
)

var AllUserPicturesConstraint = []UserPicturesConstraint{
	UserPicturesConstraintUserPicturesAccountIDKey,
	UserPicturesConstraintUserPicturesPictureURLKey,
	UserPicturesConstraintUserPicturesPkey,
}

func (e UserPicturesConstraint) IsValid() bool {
	switch e {
	case UserPicturesConstraintUserPicturesAccountIDKey, UserPicturesConstraintUserPicturesPictureURLKey, UserPicturesConstraintUserPicturesPkey:
		return true
	}
	return false
}

func (e UserPicturesConstraint) String() string {
	return string(e)
}

func (e *UserPicturesConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserPicturesConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid user_pictures_constraint", str)
	}
	return nil
}

func (e UserPicturesConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "user_pictures"
type UserPicturesSelectColumn string

const (
	// column name
	UserPicturesSelectColumnAccountID UserPicturesSelectColumn = "account_id"
	// column name
	UserPicturesSelectColumnID UserPicturesSelectColumn = "id"
	// column name
	UserPicturesSelectColumnPictureURL UserPicturesSelectColumn = "picture_url"
)

var AllUserPicturesSelectColumn = []UserPicturesSelectColumn{
	UserPicturesSelectColumnAccountID,
	UserPicturesSelectColumnID,
	UserPicturesSelectColumnPictureURL,
}

func (e UserPicturesSelectColumn) IsValid() bool {
	switch e {
	case UserPicturesSelectColumnAccountID, UserPicturesSelectColumnID, UserPicturesSelectColumnPictureURL:
		return true
	}
	return false
}

func (e UserPicturesSelectColumn) String() string {
	return string(e)
}

func (e *UserPicturesSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserPicturesSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid user_pictures_select_column", str)
	}
	return nil
}

func (e UserPicturesSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "user_pictures"
type UserPicturesUpdateColumn string

const (
	// column name
	UserPicturesUpdateColumnAccountID UserPicturesUpdateColumn = "account_id"
	// column name
	UserPicturesUpdateColumnID UserPicturesUpdateColumn = "id"
	// column name
	UserPicturesUpdateColumnPictureURL UserPicturesUpdateColumn = "picture_url"
)

var AllUserPicturesUpdateColumn = []UserPicturesUpdateColumn{
	UserPicturesUpdateColumnAccountID,
	UserPicturesUpdateColumnID,
	UserPicturesUpdateColumnPictureURL,
}

func (e UserPicturesUpdateColumn) IsValid() bool {
	switch e {
	case UserPicturesUpdateColumnAccountID, UserPicturesUpdateColumnID, UserPicturesUpdateColumnPictureURL:
		return true
	}
	return false
}

func (e UserPicturesUpdateColumn) String() string {
	return string(e)
}

func (e *UserPicturesUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserPicturesUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid user_pictures_update_column", str)
	}
	return nil
}

func (e UserPicturesUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "user_profiles"
type UserProfilesConstraint string

const (
	// unique or primary key constraint
	UserProfilesConstraintUserProfilesPkey UserProfilesConstraint = "user_profiles_pkey"
	// unique or primary key constraint
	UserProfilesConstraintUserProfilesUserIDKey UserProfilesConstraint = "user_profiles_user_id_key"
)

var AllUserProfilesConstraint = []UserProfilesConstraint{
	UserProfilesConstraintUserProfilesPkey,
	UserProfilesConstraintUserProfilesUserIDKey,
}

func (e UserProfilesConstraint) IsValid() bool {
	switch e {
	case UserProfilesConstraintUserProfilesPkey, UserProfilesConstraintUserProfilesUserIDKey:
		return true
	}
	return false
}

func (e UserProfilesConstraint) String() string {
	return string(e)
}

func (e *UserProfilesConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserProfilesConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid user_profiles_constraint", str)
	}
	return nil
}

func (e UserProfilesConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "user_profiles"
type UserProfilesSelectColumn string

const (
	// column name
	UserProfilesSelectColumnDevices UserProfilesSelectColumn = "devices"
	// column name
	UserProfilesSelectColumnID UserProfilesSelectColumn = "id"
	// column name
	UserProfilesSelectColumnUserID UserProfilesSelectColumn = "user_id"
)

var AllUserProfilesSelectColumn = []UserProfilesSelectColumn{
	UserProfilesSelectColumnDevices,
	UserProfilesSelectColumnID,
	UserProfilesSelectColumnUserID,
}

func (e UserProfilesSelectColumn) IsValid() bool {
	switch e {
	case UserProfilesSelectColumnDevices, UserProfilesSelectColumnID, UserProfilesSelectColumnUserID:
		return true
	}
	return false
}

func (e UserProfilesSelectColumn) String() string {
	return string(e)
}

func (e *UserProfilesSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserProfilesSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid user_profiles_select_column", str)
	}
	return nil
}

func (e UserProfilesSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "user_profiles"
type UserProfilesUpdateColumn string

const (
	// column name
	UserProfilesUpdateColumnDevices UserProfilesUpdateColumn = "devices"
	// column name
	UserProfilesUpdateColumnID UserProfilesUpdateColumn = "id"
	// column name
	UserProfilesUpdateColumnUserID UserProfilesUpdateColumn = "user_id"
)

var AllUserProfilesUpdateColumn = []UserProfilesUpdateColumn{
	UserProfilesUpdateColumnDevices,
	UserProfilesUpdateColumnID,
	UserProfilesUpdateColumnUserID,
}

func (e UserProfilesUpdateColumn) IsValid() bool {
	switch e {
	case UserProfilesUpdateColumnDevices, UserProfilesUpdateColumnID, UserProfilesUpdateColumnUserID:
		return true
	}
	return false
}

func (e UserProfilesUpdateColumn) String() string {
	return string(e)
}

func (e *UserProfilesUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserProfilesUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid user_profiles_update_column", str)
	}
	return nil
}

func (e UserProfilesUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "users"
type UsersConstraint string

const (
	// unique or primary key constraint
	UsersConstraintUsersAccountIDKey UsersConstraint = "users_account_id_key"
	// unique or primary key constraint
	UsersConstraintUsersGovernmentIDKey UsersConstraint = "users_government_id_key"
	// unique or primary key constraint
	UsersConstraintUsersMarketingRegionIDKey UsersConstraint = "users_marketing_region_id_key"
	// unique or primary key constraint
	UsersConstraintUsersPkey UsersConstraint = "users_pkey"
	// unique or primary key constraint
	UsersConstraintUsersProfileIDKey UsersConstraint = "users_profile_id_key"
)

var AllUsersConstraint = []UsersConstraint{
	UsersConstraintUsersAccountIDKey,
	UsersConstraintUsersGovernmentIDKey,
	UsersConstraintUsersMarketingRegionIDKey,
	UsersConstraintUsersPkey,
	UsersConstraintUsersProfileIDKey,
}

func (e UsersConstraint) IsValid() bool {
	switch e {
	case UsersConstraintUsersAccountIDKey, UsersConstraintUsersGovernmentIDKey, UsersConstraintUsersMarketingRegionIDKey, UsersConstraintUsersPkey, UsersConstraintUsersProfileIDKey:
		return true
	}
	return false
}

func (e UsersConstraint) String() string {
	return string(e)
}

func (e *UsersConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UsersConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid users_constraint", str)
	}
	return nil
}

func (e UsersConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "users"
type UsersSelectColumn string

const (
	// column name
	UsersSelectColumnAccountID UsersSelectColumn = "account_id"
	// column name
	UsersSelectColumnAddress UsersSelectColumn = "address"
	// column name
	UsersSelectColumnBirthDate UsersSelectColumn = "birth_date"
	// column name
	UsersSelectColumnContractID UsersSelectColumn = "contract_id"
	// column name
	UsersSelectColumnCreatedAt UsersSelectColumn = "created_at"
	// column name
	UsersSelectColumnGovernmentID UsersSelectColumn = "government_id"
	// column name
	UsersSelectColumnID UsersSelectColumn = "id"
	// column name
	UsersSelectColumnLastModified UsersSelectColumn = "last_modified"
	// column name
	UsersSelectColumnLocked UsersSelectColumn = "locked"
	// column name
	UsersSelectColumnMarketingRegionID UsersSelectColumn = "marketing_region_id"
	// column name
	UsersSelectColumnName UsersSelectColumn = "name"
	// column name
	UsersSelectColumnProfileID UsersSelectColumn = "profile_id"
)

var AllUsersSelectColumn = []UsersSelectColumn{
	UsersSelectColumnAccountID,
	UsersSelectColumnAddress,
	UsersSelectColumnBirthDate,
	UsersSelectColumnContractID,
	UsersSelectColumnCreatedAt,
	UsersSelectColumnGovernmentID,
	UsersSelectColumnID,
	UsersSelectColumnLastModified,
	UsersSelectColumnLocked,
	UsersSelectColumnMarketingRegionID,
	UsersSelectColumnName,
	UsersSelectColumnProfileID,
}

func (e UsersSelectColumn) IsValid() bool {
	switch e {
	case UsersSelectColumnAccountID, UsersSelectColumnAddress, UsersSelectColumnBirthDate, UsersSelectColumnContractID, UsersSelectColumnCreatedAt, UsersSelectColumnGovernmentID, UsersSelectColumnID, UsersSelectColumnLastModified, UsersSelectColumnLocked, UsersSelectColumnMarketingRegionID, UsersSelectColumnName, UsersSelectColumnProfileID:
		return true
	}
	return false
}

func (e UsersSelectColumn) String() string {
	return string(e)
}

func (e *UsersSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UsersSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid users_select_column", str)
	}
	return nil
}

func (e UsersSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "users"
type UsersUpdateColumn string

const (
	// column name
	UsersUpdateColumnAccountID UsersUpdateColumn = "account_id"
	// column name
	UsersUpdateColumnAddress UsersUpdateColumn = "address"
	// column name
	UsersUpdateColumnBirthDate UsersUpdateColumn = "birth_date"
	// column name
	UsersUpdateColumnContractID UsersUpdateColumn = "contract_id"
	// column name
	UsersUpdateColumnCreatedAt UsersUpdateColumn = "created_at"
	// column name
	UsersUpdateColumnGovernmentID UsersUpdateColumn = "government_id"
	// column name
	UsersUpdateColumnID UsersUpdateColumn = "id"
	// column name
	UsersUpdateColumnLastModified UsersUpdateColumn = "last_modified"
	// column name
	UsersUpdateColumnLocked UsersUpdateColumn = "locked"
	// column name
	UsersUpdateColumnMarketingRegionID UsersUpdateColumn = "marketing_region_id"
	// column name
	UsersUpdateColumnName UsersUpdateColumn = "name"
	// column name
	UsersUpdateColumnProfileID UsersUpdateColumn = "profile_id"
)

var AllUsersUpdateColumn = []UsersUpdateColumn{
	UsersUpdateColumnAccountID,
	UsersUpdateColumnAddress,
	UsersUpdateColumnBirthDate,
	UsersUpdateColumnContractID,
	UsersUpdateColumnCreatedAt,
	UsersUpdateColumnGovernmentID,
	UsersUpdateColumnID,
	UsersUpdateColumnLastModified,
	UsersUpdateColumnLocked,
	UsersUpdateColumnMarketingRegionID,
	UsersUpdateColumnName,
	UsersUpdateColumnProfileID,
}

func (e UsersUpdateColumn) IsValid() bool {
	switch e {
	case UsersUpdateColumnAccountID, UsersUpdateColumnAddress, UsersUpdateColumnBirthDate, UsersUpdateColumnContractID, UsersUpdateColumnCreatedAt, UsersUpdateColumnGovernmentID, UsersUpdateColumnID, UsersUpdateColumnLastModified, UsersUpdateColumnLocked, UsersUpdateColumnMarketingRegionID, UsersUpdateColumnName, UsersUpdateColumnProfileID:
		return true
	}
	return false
}

func (e UsersUpdateColumn) String() string {
	return string(e)
}

func (e *UsersUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UsersUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid users_update_column", str)
	}
	return nil
}

func (e UsersUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

